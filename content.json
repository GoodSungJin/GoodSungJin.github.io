{"pages":[],"posts":[{"title":"[Codewars] Consecutive strings","text":"(6kyu) Consecutive strings 설명 : 배열의 원소로 임의의 문자열과, 정수 k 가 들어온다. 배열의 원소들을 k개씩 잘라 합치고, 길이를 비교해 제일 긴 값을 반환한다. 12345678910111213141516171819202122232425function longestConsec(strarr, k) { var len = strarr.length; var result = []; var comp; if(len == 0 || k &gt; len || k &lt;= 0){ return ''; } for(let i = 0; i &lt; k; i++){ result += strarr[i]; } for(let i = 0; i &lt; len-k+1; i++){ for(let j = 0; j &lt; k; j++){ comp += strarr[i+j]; } if(result.length &lt; comp.length){ result = comp; } comp = []; } return result;} 내가 생각한 핵심 : 문제를 풀기 전까지는 몰랐는데 풀면서 확인해보니 배열의 문자열을 comp에 더해주니까 하나의 문자열로 합쳐졌다. 이런 상황은 생각하고 풀지 않았는데 풀어보니 암묵적 형변환이 일어나서 오늘 배운 내용이 생각나면서 신기했다.","link":"/2019/05/07/algorithm-codewars-consecutive-strings/"},{"title":"[Codewars] Directions Reduction","text":"(5kyu) Directions Reduction 설명 : NORTH, SOUTH, WEST, EAST 가 랜덤의 문자열로 들어온다. 차례로 인접한 NORTH : SOUTH 와 WEST, EAST를 삭제한다. 남은 문자열을 return한다. 12345678910111213141516function dirReduc(arr){ for(var i=0; i &lt;= arr.length-1; i++){ if((arr[i] == \"NORTH\" &amp;&amp; arr[i+1] == \"SOUTH\") || (arr[i] == \"SOUTH\" &amp;&amp; arr[i+1] == \"NORTH\") || (arr[i] == \"WEST\" &amp;&amp; arr[i+1] == \"EAST\") || (arr[i] == \"EAST\" &amp;&amp; arr[i+1] == \"WEST\")){ arr.splice(i, 2); if(i &gt;= 1){ i = 0; } i--; } } return arr;} 내가 생각한 핵심: 조건에 맞으면 삭제하고, 맞지 않으면 i++가 된다. 이때, 다음 반복문안에 조건이 맞으면 처음 건너뛴 값은 비교할 수가 없어서 i &gt;= 1 상황일 때 0으로 초기화 해주었다.","link":"/2019/04/19/algorithm-codewars-directions-reduction/"},{"title":"[Codewars] Double Cola","text":"(5kyu) Double Cola 설명 : ‘Sheldon’, ‘Leonard’, ‘Penny’, ‘Rajesh’, ‘Howard’ 가 기본으로 할당되어있다. 정수 값 r 을 받으면 배열의 r 번째 문자를 반환한다. 배열의 0번째 인덱스는 콜라를 먹으면 사라지고 뒤에 두명이 붙는다. 12345678910function whoIsNext(names, r) { var n = 0; var interval = 0; while(r &gt; interval){ interval += names.length * 2 ** n; n++ } return names[Math.ceil((r-(interval-(names.length * 2 ** (n-1)))) / 2**(n-1))-1];} 내가 생각한 핵심 : 여태껏 풀었던 알고리즘 문제중에 제일 어렵고 화가 났다. 꼬박 하루가 걸려서 문제를 이해하고 풀었다. 문제의 이해를 위해 수작업으로 하나 하나 계산해봤다. 그 결과 콜라를 한번 먹고 다시 자리로 돌아오기 까지 n2 이 된다는 사실을 알았고, 그때 마다 반복되는 문자의 개수는 2n 된다는 사실을 알았다. 다시 자리로 돌아오기 까지의 구간을 구하려고 interval의 식을 세우는 과정이 정말 생각이 안났다. 이 문제는 지금의 내 알고리즘 한계를 조금은 뛰어 넘는 문제가 아니였나 싶다.","link":"/2019/05/03/algorithm-codewars-double-cola/"},{"title":"[Codewars] Exes and Ohs","text":"(7kyu) Exes and Ohs 설명 : x와 o가 대소문자 구분없이 들어온다. x와 o의 수가 같으면 true 를 return 하고, 같지 않으면 false를 return한다. 123456789101112131415161718192021function XO(str) { var count1 = 0; var count2 = 0; str1 = str.toUpperCase(); for(var i=0; i &lt;= str.length; i++){ if(str1[i] === 'O'){ count1 += 1; } else if(str1[i] === 'X'){ count2 += 1; } } if(count1 === count2){ return true; } else { return false; } } 내가 생각한 핵심 : x와 o가 대소문자 구분이 상관없어서 대문자로 다 바꿔서 비교했다.","link":"/2019/04/17/algorithm-codewars-exes-and-ohs/"},{"title":"[Codewars] Multiples of 3 or 5","text":"(6kyu) Multiples of 3 or 5 설명 : 임의의 정수값 number가 들어온다. number에서 3과 5의 배수만 받아 합한다. 이때, 3과 5의 공배수는 한 번만 더해주고, return한다. 12345678910111213141516function solution(number){ var sum = 0; for(var i=1; i&lt;=number; i++){ if(3*i &lt; number){ sum += 3 * i; } if(5*i &lt; number){ sum += 5 * i; } if (i*15 &lt; number) { sum -= 15 * i; } } return sum;} 내가 생각한 핵심: 3과 5의 공배수를 1번만 더해줘야해서, 최소 공배수인 15를 기준으로 반복횟수 * 15가 number 보다 초과면 15를 반복횟수 만큼 빼준다.","link":"/2019/04/16/algorithm-codewars-multiples-of-3-or-5/"},{"title":"[Codewars] Persistent Bugger","text":"Persistent Bugger 설명 : 임의의 양수 num을 받아 각 자릿수를 독립된 수로 나눈다. 나눈 수끼리 곱셈을 하고, 곱셈된 값을 나눠 지속 곱셈을 한다. 자릿수가 1에 도달하면, 몇번 곱셈 됐는지 return 한다. 123456789101112131415function persistence(num) { var j = 0; while (num &gt;= 10) { arry = String(num).split(\"\"); var sum = 1; for (var i = 0; i &lt; arry.length; i++) { sum *= Number(arry[i]); } num = sum; j++; } return j;} 내가 생각한 핵심: 곱셈된 값을 나누는 작업을 반복하기 때문에 곱셈된 값을 num으로 초기화 해주고, 곱셈된 횟수의 return을 위해 j 를 ++ 해준다.","link":"/2019/04/18/algorithm-codewars-persistent-bugger/"},{"title":"[Codewars] Take a Number And Sum Its Digits Raised To The Consecutive Powers And ...Eureka!!","text":"(6kyu) Take a Number And Sum Its Digits Raised To The Consecutive Powers And …Eureka!! 설명 : start = a, end = b 의 정수값을 받아 범위에 있는 숫자를 계산한다. 받아온 임의의 값 num = 537 을 각각 자릿수의 n제곱(537 = 5 : 1, 3 : 2, 7 : 3 = 5^1 + 3^2 + 7^3)하여 합산한다. 합산한 값이 num과 같으면 배열에 추가하여 return한다. 1234567891011121314151617function sumDigPow(a, b) { var sum = 0; var arr = []; for(i=a; i &lt;= b; i++){ str_num = String(i).split(''); for(j=0; j&lt;str_num.length; j++){ sum += Number(str_num[j])**(j+1); if(i == sum){ arr.push(i); } } sum = 0; }return arr;}","link":"/2019/04/26/algorithm-codewars-take-a-number/"},{"title":"[Codewars] Playing with digits","text":"(6kyu) Playing with digits 설명 : 임의의 정수 n과 p를 받아온다. p는 n의 앞자리 승수를 결정하여 순차적으로 1씩 늘어난다. n을 자릿수 별로 나눠서 승수로 제곱하고 모든 자릿수를 더한다. 더해진 자릿수가 원래 들어온 n의 배수로 딱 떨어지면 몇배수인지 return한고, 그렇지 않으면 -1 을 return한다. 123456789101112131415161718function digPow(n, p){ var arr = String(n).split(''); var sum = 0, result = 0; for(let i = 0; i &lt; arr.length; i++){ sum += Number(arr[i])**p; p++ } while(sum-(n*result) != 0){ result++ if(sum-(n*result) &lt; 0){ return -1; } } return result;} 내가 생각한 핵심: 배수가 맞다면 몇배수인지를 확인하는 작업을 생각하는게 어려웠다. 나는 (모두가 합쳐진 값) - (원래들어온값*배수를 확인하는 임의의 정수)로 식을 세웠는데, 다른 스터디원은 sum/n 으로 간단하게 해결했다.","link":"/2019/05/02/algorithm-codewars-playing-with-digits/"},{"title":"[LeetCode] 14. Longest Common Prefix","text":"14. Longest Common Prefix 설명 : 임의로 주어진 문자열들의 문자를 비교한다. 가장긴 같은 문자를 return한다. 12345678910111213141516171819202122/** * @param {string[]} strs * @return {string} */var longestCommonPrefix = function(strs) { let longestPrefix = ''; if (strs.length &gt; 0) { longestPrefix = strs[0]; for (let i = 1; i &lt; strs.length; i++) { for (let j = 0; j &lt; longestPrefix.length; j++) { if (strs[i][j] != longestPrefix[j]) { longestPrefix = longestPrefix.slice(0, j); break; } } } } return longestPrefix; }; 내가 생각한 핵심 : 문자열중에 기준을 하나로 잡고, 문자하나씩 비교해가며, 틀린 글자가 나오면 자르고 기준이 되는 문자로 초기화 한다.","link":"/2019/03/28/algorithm-leetcode-longest-common-prefix/"},{"title":"Assignment TodoList version 4.0.0","text":"TodoList (Angular)TodoList Angular 버젼이다. 각각의 기능별로 컴포넌트를 나눠 Root 컴포넌트에서 호출하여 View를 완성한다. Root Component123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import { Component, ViewEncapsulation } from '@angular/core';import { Todo } from '../interface-todo';import { Tabs } from '../interface-tabs';@Component({ selector: 'app-todos', template: ` &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;4.0&lt;/div&gt; &lt;app-input-todo (addTodo)=\"addTodo($event)\"&gt;&lt;/app-input-todo&gt; &lt;app-nav-todo [tabsData]=\"tabs\" [tabStateData]=\"tabState\" (changeTabState)=\"tabState = $event\"&gt;&lt;/app-nav-todo&gt; &lt;app-list-todo [todosData]=\"Todos\" (toggleCheck)=\"changeCk($event)\"&gt;&lt;/app-list-todo&gt; &lt;app-footer-todo (cheakAll)=\"checkAll($event)\" (removeTodo)=\"removeTodo()\" [countActive]=\"countActive\" [countComplete]=\"countComplete\"&gt;&lt;/app-footer-todo&gt; &lt;/div&gt; `, styleUrls: ['./todos.component.css'], encapsulation: ViewEncapsulation.None})export class TodosComponent { todos: Todo[] = [ { id: 1, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 3, content: 'Javascript', completed: false } ]; tabs: Tabs[] = [ { content: 'All' }, { content: 'Active' }, { content: 'Complete' } ]; tabState = 'All'; get Todos() { if(this.tabState === 'All') return this.todos; else if(this.tabState === 'Active') return this.todos.filter(todo =&gt; todo.completed); return this.todos.filter(todo =&gt; !todo.completed); } // todo 추가 addTodo(elem: HTMLInputElement) { this.todos = [...this.todos, { id: this.generateId(), content: elem.value, completed: false}] elem.value = ''; } // 아이디 자동 만들기 generateId() { return this.todos.length ? Math.max(...this.todos.map(todo =&gt; todo.id)) + 1 : 1; } // 체크박스 상태변화 changeCk(id: number) { this.todos = this.todos.map(todo =&gt; { if (id !== todo.id) return todo; return {...todo, completed: !todo.completed} }) } // completed 카운트 get countComplete() { return this.todos.filter(todo =&gt; todo.completed).length; } // active 카운트 get countActive() { return this.todos.filter(todo =&gt; !todo.completed).length; } // 전체 체크 checkAll(ck: boolean) { this.todos = this.todos.map(todo =&gt; { return ck ? {...todo, completed: true} : {...todo, completed: false}; }) } // completed 삭제 removeTodo() { this.todos = this.todos.filter(todo =&gt; !todo.completed); }} Input Component123456789101112import { Component, Output, EventEmitter } from '@angular/core';@Component({ selector: 'app-input-todo', template: ` &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus (keyup.enter)=\"addTodo.emit($event.target)\"&gt; `, styleUrls: ['./input-todo.component.css']})export class InputTodoComponent { @Output() addTodo = new EventEmitter();} Navigation Component123456789101112131415161718import { Component, Input, Output, EventEmitter } from '@angular/core';import { Tabs } from '../interface-tabs';@Component({ selector: 'app-nav-todo', template: ` &lt;ul class=\"nav\"&gt; &lt;li *ngFor=\"let tab of tabsData\" [class.active]=\"tab.content === tabStateData\" (click)=\"changeTabState.emit(tab.content)\"&gt;{{tab.content}}&lt;/li&gt; &lt;/ul&gt; `, styleUrls: ['./nav-todo.component.css']})export class NavTodoComponent { @Input() tabsData: Tabs[]; @Input() tabStateData: string; @Output() changeTabState = new EventEmitter();} Footer Component12345678910111213141516171819202122232425import { Component, Output, EventEmitter, Input } from '@angular/core';@Component({ selector: 'app-footer-todo', template: ` &lt;div class=\"footer\"&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"custom-checkbox\" type=\"checkbox\" id=\"ck-complete-all\" (change)=\"cheakAll.emit($event.target.checked)\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\" (click)=\"removeTodo.emit()\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;{{countComplete}}&lt;/span&gt;) &lt;/button&gt; &lt;strong class=\"active-todos\"&gt;{{countActive}}&lt;/strong&gt; items left &lt;/div&gt; &lt;/div&gt; `, styleUrls: ['./footer-todo.component.css']})export class FooterTodoComponent { @Output() cheakAll = new EventEmitter(); @Output() removeTodo = new EventEmitter(); @Input() countActive: number; @Input() countComplete: number;}","link":"/2019/06/19/assign-todoV4/"},{"title":"[LeetCode] 7. Reverse Integer","text":"7. Reverse Integer 설명: 임의의 정수를 x를 받는다. 값을 그대로 반전시켜 return한다. 123456789101112131415161718192021222324252627/** * @param {number} x * @return {number} */var reverse = function(x) { var i = 1, sum = 0; var temp = x; var x_length; if(temp &lt; 0){ x_length = x.toString().length - 1; } else{ x_length = x.toString().length; } while(i &lt;= x_length){ sum += (temp%10) * (Math.pow(10, (x_length-i))); temp = parseInt(temp/10); i++ } if(Math.pow(-2, 31) &gt; sum || Math.pow(2, 31) &lt; sum){ return 0; } return sum;};","link":"/2019/03/27/algorithm-leetcode-reverse-integer/"},{"title":"[LeetCode] 1. Two Sum","text":"1. Two Sum 설명 : 임의의 정수 배열 nums와 목표 값 target을 받는다. nums 중 2개의 정수를 더해 target값과 동일하면 return한다. 1234567891011121314/** * @param {number[]} nums * @param {number} target * @return {number[]} */var twoSum = function(nums, target) { for(var i=0; i&lt;=nums.length; i++){ for(var j=i+1; j&lt;=nums.length; j++){ if(nums[i] + nums[j] == target){ return [i, j]; } } }};","link":"/2019/03/26/algorithm-leetcode-two-sum/"},{"title":"웹 사이트의 구조, 웹 접근성과 웹 표준","text":"1. 웹사이트의 구조 HTML(Hyper Text Markup Language)구조를 잡는다. (건강한 신체) CSS(Casecade Style Sheets)html 요소들을 꾸민다. (화려한 스타일) Javascript정적인 페이지를 동적으로 변화시켜준다. (스마트한 두뇌) 2. 웹 접근성과 웹 표준2.1. 웹 표준(Web Standards) W3C (World Wide Consortium)에서 정의하는 기술 표준을 또는 규격을 말한다. 웹 표준의 궁극적인 목적은 웹사이트에 접속한 사용자가 어떠한 운영체제나 브라우저를 사용하더라도 동일한 결과를 보이게 하는 것이다. 2.1.1. 웹 표준이 되는 과정 Working Draft(WD) : 초안 Candidate Recommendation(CR) : 후보 권고안 Proposed Recommendation(PR) : 제안권고안 W3C Recommendation(REC) : 권고안 2.2. 웹 접근성(Web Accessibility)장애인, 고령자 등 모든 사용자가 어떠한 기술이나 환경에서도 전문적인 능력 없이 웹사이트에서 제공하는 모든 정보를 동등하게 접근하고 이해할 수 있는 권리입니다. 장애는 볼수없는것이 아니라 보는 방법이 다를뿐 (서울대 이상묵교수님) 2.2.1. 신체적인 접근성(장애) 시력장애, 청각장애, 지체장애, 뇌병변장애 그 외 신체적 장애 2.2.2. 환경에 대한 이해 다양한 Platform Cross Browsing SEO(Search Engine Optimization) 저사양 또는 저속회선 3. HTML(HyperText Markup Language)HTML은 웹 페이지 제작을 위한 마크업 언어다. 3.1. 의미론적 마크업(Sementic Markup)HTML 태그는 의미를 가진 태그와 의미를 가지지 않은 태그로 나뉘어져있다. 웹페이지에서 같은 모양으로 출력된다고 해도, 실제로 가지고 있는 의미는 서로 다를 수 있다. 예를 들어 태그를 안쓰고도 제목 모양의 스타일링을 할 수는 있지만 그것은 ‘표현’ 영역에 해당하고 내용-구조를 담당하는 HTML의 역할을 다 했다고 하기 어려운 것이다. 3.2. 검색엔진최적화(SEO, Search Engine Optimization)검색엔진최적화(Search Engine Optimization)란, 웹사이트의 HTML 코드에서 정보를 모아 검색 키워드에 맞는 적절한 웹사이트를 보여주기 위한 것이다. 따라서 HTML의 요소들을 가지고 해당 웹페이지의 내용을 파악하고 그것이 검색엔진에 노출될 수 있도록 하기 위해서 시멘틱한 마크업이 필요하다.","link":"/2019/04/01/til-20190401/"},{"title":"css프로퍼티, 애니메이션","text":"1. CSS 프로퍼티 1.1. linear-gradient() 배경 및 색깔에 그라데이션이 필요할 때 사용한다. linear-gradient 앞쪽에 색을 선언하면 그라데이션이 안먹을 경우 앞에 선언한 컬러가 적용됨 123box{ background: black linear-gradient(to bottom, white 0%, gray 50%, black 100%);} 1.2. white-space스페이스와 탭, 줄바꿈, 자동줄바꿈의 처리 방식을 정할 때 사용한다. normal 자동 줄바꿈 - O, 스페이스및 탭 - 병합 nowrap 자동 줄바꿈 - X, 스페이스및 탭 - 병합 pre 자동 줄바꿈 - X, 스페이스및 탭 - 기본 pre-wrap 자동 줄바꿈 - O, 스페이스및 탭 - 기본 pre-line 자동 줄바꿈 - O, 스페이스및 탭 - 병합 1.3. ::after ::before 다른 선택자의 뒤에 함께 쓰여 원하는 텍스트 및 스타일을 넣거나 지정할 때 사용한다. 가상요소 선택자를 쓸 경우 필수로 content 속성이 필요하다. 123box::after{ content: \"o\";} 2. CSS 애니메이션 2.1. @keyframes정해진 시간분할에 따라 %, from-to 단위로 애니메이션(animation)을 구현하기 위한 것이며 이를 위해 animation 속성 사용 후 keyframe 과 연결하여 애니메이션을 구현한다. 12345678910111213141516171819202122/* % */@keyframes percentage{ 0%{ opacity: 0; } 50%{ opacity: 1; } 100%{ opacity: 0.3; }}/* from-to */@keyframes from-to{ from{ height: 0; } to{ height: 100px; }} 2.2. animation-name어떤 keyframe을 연결할지 지정한다. 2.3. animation-duration애니메이션이 얼마 동안 구현 될지에 대한 시간을 지정한다. 2.4. animation-delay애니메이션을 즉시 재생하지 않고 지정한 시간 동안 지연 후 재생하도록 한다. 2.5. animation-fill-mode애니메이션의 시작/끝 상태를 제어한다. 2.6. animation-iteration-count애니메이션 반복 횟수를 지정한다.(infinite, 무한대) 2.7. animation-timing-function애니메이션이 재생될 때의 시간차에 대한 함수를 지정한다. 2.8. ease, linear, ease-in, ease-out, ease-in-out특정 곡선이 아닌 임의의 시간차를 필요로 할 경우에는 cubic-bezier 함수를 사용한다. 2.9. animation-direction 애니메이션이 어떤 형식으로 반복할지에 대한 반복형식을 지정한다. alternate로 지정하는 경우 from에서 to로 갔다가 다시 to에서 from으로 가도록 한다. animation-direction 속성이 제대로 동작하려면 animation-iteration-count 속성에 반복 횟수가 지정되어 있어야 한다. 2.10. animation-play-state 애니메이션의 재생 상태를 지정한다. paused 값을 사용해 애니메이션을 일시적으로 정지 시킬 수 있다. 1234567891011.box{ animation-name: from-to; animation-duration: 3.3s; animation-delay: 2s; animation-fill-mode: forwards; animation-iteration-count: infinite; animation-timing-function: linear; animation-direction: alternate; animation-play-state: running; height: auto;}","link":"/2019/04/03/til-20190403/"},{"title":"css의 상속, 겹침, 우선순위, layout","text":"1. CSS(Casecade Style Sheets) 1.1. 가장 중요한 3가지 상속layout 프로퍼티는 상속받지 않고, decoration 프로퍼티만 상속받는다. 겹침가장 마지막에 선언된 스타일이 우선순위가 높다. 우선순위선택자 각각의 우선순위를 구별할 수 있어야한다. 선택자 점수 태그 (tag) 1점 클래스 (class) 10점 아이디 (id) 100점 1.2. Layout 1.2.1.display block view포트를 기준으로 한줄을 다 차지하여, 줄 바꿈이 일어나고 크기를 지정할 수 있다. inline 콘텐츠의 크기에 맞게 사이즈가 조절되어, 줄 바꿈이 일어나지 않고, 크기조절이 불가하다. inline-block 혼합된 형태로 크기조절이 가능하고, 줄 바꿈이 일어나지 않는다. flex 다른 속성들과 다르게 유연함을 가지고 있다. grid 세로 열과 가로 행의 테이블형식으로 만들어 위치를 마음대로 이동시킬 수 있다. 1234567.layout { display: block; display: inline; display: inline-block; display: flex; display: grid;} 1.2.2. position static 모든 태그의 기본 상태이고 왼쪽에서 오른쪽, 위에서 아래로 정렬된다. relative 선택된 요소를 기준으로 top, right, bottom, right를 사용하여 위치를 움직일 수 있다. absolute static 속성이 아닌 부모를 기준으로 top, right, bottom, right를 사용하여 움직일 수 있다. fixed 상단의 메뉴바에 많이 쓰이는 속성으로, 고정된 자리를 가진다. 123456.layout { position: static; position: relative; position: absolute; position: fixed;} 1.2.3. float left 일반적인 흐름에서 벗어나 공중에 붕 떠있는 형태로 왼쪽 정렬을 한다. right 일반적인 흐름에서 벗어나 공중에 붕 떠있는 형태로 오른쪽 정렬을 한다. 1234.layout { float: left; float: right;} 2. emmet모든 에디터에 제공되는 자동완성 기능이다.ex) ul.member&gt;li*5&gt;a[href=&quot;#&quot;] 123456789&lt;!-- ul.member&gt;li*5&gt;a[href=\"#\"] --&gt;&lt;ul class=\"member\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;","link":"/2019/04/02/til-20190402/"},{"title":"HTML, Form","text":"HTML 1. 폼(Form)사용자의 입력(로그인, 메일전송, 설문 등)을 받아 데이터를 전달하는 영역이다. fieldset 요소 form과 fieldset은 세트이다. 관련 컨트롤을 하나의 그룹으로 묶는다. legend 요소 fieldset과 세트로, fieldset의 제목을 표시한다. action 속성 form의 속성으로 보내고자 하는 곳의 주소(URL)을 지정해준다. method 속성 form의 속성으로 데이터를 주고받는 방식을 지정해준다. get : URL에 데이터가 노출되며, 데이터가 header에 포함되어 있다. ex) 검색 post : 데이터가 body에 포함되어, 노출되지 않는다. ex) 로그인 input 요소 사용자가 정보를 입력하는 창이다. lable 요소 input요소와 세트로, input의 이름을 입력해준다. for 속성을 이용하면 텍스트 클릭만으로 input에 연결해준다. (input에 id값 필수) 1234567891011121314&lt;form action=\"URL\" method=\"POST\"&gt; &lt;fieldset&gt; &lt;legend&gt;회원 로그인 폼&lt;/legend&gt; &lt;div class=\"user-email\"&gt; &lt;label for=\"user-email\"&gt;아이디&lt;/label&gt; &lt;input type=\"email\" id=\"user-email\"&gt; &lt;/div&gt; &lt;div class=\"user-pw\"&gt; &lt;label for=\"user-pw\"&gt;비밀번호&lt;/label&gt; &lt;input type=\"password\" id=\"user-pw\"&gt; &lt;/div&gt; &lt;button class=\"btn-login\" type=\"submit\"&gt;로그인&lt;/button&gt; &lt;/fieldset&gt;&lt;/form&gt;","link":"/2019/04/04/til-20190404/"},{"title":"CSS, Flex","text":"CSS 1. flex1.1. display: flexCSS3에 새롭게 추가된 유연한 박스 레이아웃을 말한다.두 개의 x, y축을 기준으로 주축을 결정하고, 나머지 축을 교차축으로 지정한다. 123box{ display: flex;} 1.2. flex-direction 속성요소 박스의 배치 방향을 지정한다. row : x축을 기준으로 가로방향으로 배치한다. (기본값) row-reverse : x축을 순서를 반전시켜 가로방향으로 배치한다. column : y축을 기준으로 세로방향으로 배치한다. column-reverse : y축을 기준으로 순서를 반전시켜 세로방향으로 배치한다. 1234box{ display: flex; flex-direction: column;} 1.3. flex-wrap 속성요소 박스를 한 줄 또는 여러 줄로 지정한다. none : 단일 행, 단일 열로 배치한다. wrap : 여러줄로 배치한다. wrap-reverse : 반전시켜 여러줄로 배치한다. 12345box{ display: flex; flex-direction: column; flex-wrap: wrap-reverse;} 1.4. align-items 속성요소박스의 교차축을 기준으로 정렬한다. flex-direction: row;일 경우 세로정렬을 지정한다. flex-direction: column;일 경우 가로정렬을 지정한다. 12345box{ display: flex; flex-direction: row; align-items: center;} 1.5. justify-content 속성flex-direction 속성에 따라 축을 기준으로 자식요소의 정렬 방식을 지정한다. flex-start : 주축을 기준으로 첫지점부터 정렬한다. flex-end : 주축을 기준으로 마지막지점부터 정렬한다. center : 주축을 기준으로 가운데 정렬한다. space-between : 주축을 기준으로 맨 끝과 끝에서부터 정렬한다.(말을 잘 못하겠음) space-around : 주축을 기준으로 같은 간격을 유지하여 정렬한다. (말을 잘 못하겠음) 123456box{ display: flex; flex-direction: column; flex-wrap: wrap-reverse; justify-content: center;} 1.6. order 속성자식요소 지정하는 속성으로 박스의 배치 순서를 지정한다. 12345678910111213box{ display: flex; flex-direction: column; flex-wrap: wrap-reverse;}baby1-box{ order: 1;}baby2-box{ order: -1;} 1.7. flex-grow 속성자식요소에게 지정하는 속성으로 부모요소의 크기에 맞게 자동으로 비율을 조정한다. ex) 자식요소의 박스 크기를 2:3:1 비율로 지정한다.123456789101112131415161718box{ display: flex; flex-direction: column; flex-wrap: wrap-reverse;}baby1-box{ order: 1; flex-grow: 2;}baby2-box{ order: -1; flex-grow: 3;}baby3-box{ flex-grow: 1;}","link":"/2019/04/08/til-20190408/"},{"title":"HTML, dl, dt, dd, CSS속성","text":"HTML 1. dl, dt, dd용어를 정의할 때 사용한다. dl : 용어를 설명하는 목록을 만들 때 사용한다. dt : 용어의 제목을 넣을 때 사용한다. dd : 용어를 설명할 때 사용한다. (dt:dd 뿐 아니라, dt: dd여러개로도 사용가능) 123456&lt;dl&gt; &lt;dt&gt;최성진&lt;/dt&gt; &lt;dd&gt;실용음악과&lt;/dd&gt; &lt;dd&gt;기타전공&lt;/dd&gt; &lt;dd&gt;엄청난 개발자가 될 준비 중&lt;/dd&gt;&lt;/dl&gt; 2. a다른 페이지로 연결하는 데 사용하는 하이퍼 링크를 정의한다. href속성 URL값을 지정해준다. target속성 _blank: 새창에서 로드 _parent: 부모창에서 로드 _self: 현재창에서 로드 _top: 최상위창에서 로드 1&lt;a href=\"https://www.naver.com\" target=\"_blacnk\"&gt;네이버 새창에서 열기&lt;/a&gt; CSS 1. line-height 속성줄 간격을 지정한다. normal : 기본값으로 브라우저의 기본 속성을 따른다. 보통 1.2이다. number : 폰트 사이즈를 기준으로 설정한 몇 배인지 설정한다. length : px, em, cm 등의 단위의 길이로 높이를 설정한다. percentage : 퍼센트만큼 설정한다. 123456box{ line-height: normal; line-height: 3; line-height: 10cm; line-height: 30%;} 2. vertical-align 속성글자의 세로 정렬을 지정한다. baseline : 기본값으로 부모의 기준선에 맞춰 설정한다. top : 요소의 가장 상단에 맞춰 정렬한다. middle : 부모 요소의 중앙에 맞춘다. bottom : 요소의 가장 아래에 맞춰 정렬한다. text-top : 부모 요소의 text 위에 맞춰 정렬한다. text-bottom : 부모 요소의 text 아래에 맞춰 정렬한다. 12345678box{ vertical-align: baseline; vertical-align: top; vertical-align: middle; vertical-align: bottom; vertical-align: text-top; vertical-align: text-bottom;} 3. cursor 속성해당 영역에 표시되는 마우스 커서의 모양을 설정한다. auto : 기본값으로 브라우저에 따라 자동으로 설정한다. default : 기본값(화살표)으로 설정한다. pointer : 손가락 모양으로 설정한다. wait : 로딩중모양으로 설정한다. 123456box{ cursor: auto; cursor: default; cursor: pointer; cursor: wait;} 4. font-weight 속성text의 굵기를 지정한다. normal : 기본값으로 지정한다. bold : 굷게 지정한다. bolder : 부모 요소보다 굷게 지정한다. lighter : 부모 요소보다 얇게 지정한다. 100~300 : normal보다 얇게 지정한다. 400 : normal과 동일하게 지정한다. 500~600 : normal보다 굷게 지정한다. 700 : bold와 동일하게 지정한다. 800~900 : bold보다 굷게 지정한다. 123456box{ font-weight: normal; font-weight: bold; font-weight: 100; font-weight: 900;}","link":"/2019/04/05/til-20190405/"},{"title":"CSS 선택자","text":"CSS 1. CSS Selector 우선순위CSS스타일을 적용할 때, class, id, tag 선택자를 사용하는데 이 것들의 우선순위를 알아야한다. 제일 마지막에 선언된 스타일이 우선 적용된다. 선택자별 적용 순서는 점수로 계산되어 더 높은 점수가 우선 적용된다. 선택자 점수 tag 1점 class 10점 id 100점 1.1. 선택자(Selector)의 종류 전체 선택자(universal selector) html 내부에 있는 모든 요소를 선택한다. 123* { color: skyblue;} 태그 선택자(tag selector) html 내부의 특정 요소를 선택한다. 123h1{ font-size: 10px;} 클래스 선택자(class selector) html 내부의 특정 class 속성값을 선택한다.선택시 . 마침표를 앞에 붙여준다. 123.menu-item{ margin: 10px;} 아이디 선택자(id selector) html 내부의 특정 id 속성값을 선택한다.선택시 # 샵을 앞에 붙여준다. 123#menu{ padding: 15px;} 복합 선택자(combinator) html 내부의 요소, id, class 등을 두개 이상 선택한다.div a A 요소의 자식, 자손인 B 요소를 모두 선택한다.div &gt; a A 요소의 자식인 B요소만 선택한다. 1234567h1 .menu-item{ font-weight: 15px;}h1 &gt; .menu-item{ color: pink;} 인접 형제 선택자(adjacent sibling combinator) 형제중 첫번째 동생요소가 조건을 충족시키면 선택한다.div+a div요소 뒤에 a요소가 바로 있으면 선택한다. 123div+.menu-item{ color: pink;} 일반 형제 선택자(general) sibling combinator) 조건을 충족하는 모든 동생 요소를 선택한다.div~a div요소 뒤에 있는 a요소를 다 선택한다. 123div~.menu-item{ color: pink;} 2. transform &amp; transition 속성transform 은 좌표공간을 변형함으로써, 다른 엘리먼트에 영향을 미치지 않고 요소의 위치를 이동시킬 수 있고, transition 을 사용하여 transform 이 진행되는 시간을 지정할 수 있다. transform평면에서 회전을 할 수 있다. rotate 2turn : 2번 회전한다. 360deg : 360도 회전한다. translate : x축, y축으로 이동한다. transition애니메이션 속도를 조절한다. transition-property : 속성의 이름을 명시한다. transition-duration : 진행 지속 시간을 명시한다. 12345678910111213.box{ background: yellow; width: 300px; height: 300px; transition: all 1s;}.box:hover, .box:focus{ outline: 0; background: pink; border-radius: 50%; transform: rotate(2turn) translate(30px, 30px);}","link":"/2019/04/09/til-20190409/"},{"title":"Bubble Sort","text":"Bubble sort단순정렬 알고리즘으로, 서로 인접한 두 원소를 비교하여 앞에 원소가 뒤에 원소보다 크면 위치를 변경해 정렬한다. 배열의 처음부터 2개씩 (데이터개수-1) 번 반복하여 작은수부터 정렬한다. 시간 복잡도 (데이터 개수 - 1)번 반복하여 비교한다. 등차수열을 이용해 계산한다. O(n2) 데이터가 많아질수록 기하급수적으로 느려진다. 1234567891011121314151617function bubble_sort(li){ var n = n.length(); var temp; for(let i = 0; i &lt; n-1; i++){ for(let j = 0; j &lt; n-1-i; j++){ if(li[j] &gt; li[j+1]){ temp = li[j]; li[j] = li[j+1]; li[j+1] = temp; } } }}var li = [3, 1, 8, 3, 5];bubble_sort(li);","link":"/2019/04/22/til-20190422/"},{"title":"반응형웹","text":"HTML 1. 반응형웹(Responsive Web)사용자의 환경(스크린 사이즈, 플랫폼, 회전 방향 등)을 고려하여 환경에 맞춰 반응하도록 제작하는 것을 말한다. 단위기본적으로 px, cm 단위의 고정값을 지양하고, %, em, vh, vw 등의 비율 기준의 단위를 사용한다. 등장배경모바일의 등장으로, 크기의 다양성이 많아져 사용자의 환경에 맞는 레이아웃 제공을 위해 사용하기 시작했다. 초기에는 HTML과 CSS를 두개씩 만들어 사용했지만, 비용과 시간이 너무 많이 들어가, 해결방안으로 등장한게 반응형 웹이다. 미디어쿼리(media queries)조건에 맞는 크기로 대응하여, 레이아웃을 변경할 수 있다. 이미지 아트디렉션무조건 사진의 원본사이즈를 줄이는게 아니라 중요한 부분만 잘라서 보여준다. 래핑이미지, 동영상을 반응형으로 제작할 때는 기준이 되는 부모요소가 필요하여, 요소를 div로 래핑하는 작업이 필요하다.img는 1번 래핑하고, iframe은 2번 래핑이 필요하다.","link":"/2019/04/10/til-20190410/"},{"title":"Selection Sort","text":"Selection Sort배열의 가장 작은 값부터 앞으로 옮기면서 정렬한다. 배열의 최솟값 찾기 찾은 값을 맨 앞의 값과 바꾼다. 바꾼 값 다음부터 다시 찾는다. Bubble sort와 같은 단순정렬, O(n2) 1234567891011121314function selection_sort(li){ var n = li.length(); for(let i = 0; i &lt; n-1; i++){ let min_idx = i; for(let j = i+1; j &lt; n; j++){ if(li[j] &lt; li[min_idx]){ min_idx = j; } } [li[i], li[min_idx]] = [li[min_idx], li[i]]; }}","link":"/2019/04/23/til-20190423/"},{"title":"Memory, 기수법","text":"1. Memory 1. 1. 32bit vs 64bit 의 차이1. 와이어 cpu와 ram (main memory)을 연결하는 와이어의 개수를 각 1bit로 계산한다. 이때 와이어의 개수가 32개로 연결되어 있으면 32bit 컴퓨터, 64개로 연결 돼있으면 64bit 컴퓨터인 것이다. 2. 메모리의 주소값 1digit(수를 표현할 수 있는 자릿수) = 1bit 8bit = 1byte 32bit = 4byte 64bit = 8byte cpu 에서 memory로의 데이터 전송은 전압을 통해 진행되는데, 이때 전압은 0V = 0 (2) 와 5V = 1 (2) 를 사용한다. 32bit 컴퓨터의 경우 표시할 수 있는 주소값은 232bit = 4gb 이기 때문에, 램을 4g 이상으로 사용해도 소용이 없다. 2. Number2.1. 기수법 2진수 : 0, 1 (표현할 수 있는 글자수 radix 가 2개) 10진수 : 0~9 (radix 10개) 16진수 : 0~f (radix 16개) 2.2. 진수의 변환 10진수 &gt; 2진수 1234567891011예) 64 = 2의6승 = 100 0000 (사용자의 가독성을 위해 4개씩 끊어서 써놨다.) 37 = 2의5승 + 5 2의2승 + 1 2의0승 표현은 처음 승수인 5를 기준으로 5, 4, 3, 2, 1, 0 으로 표현하고, 더해진 승수가 있으면 1로 없으면 0으로 치환한다 1 0 0 1 0 1 100101 2진수 &gt; 10진수 123456예) 100101 = 총 6자리기 때문에 가장큰 승수는 5 1 0 0 1 0 1 2의5승 + 없음 + 없음 + 2의2승 + 없음 + 2의0승 = 37 2진수 &gt; 16진수 12345678910111213141516171819202122232416진수의 시작은 0x 로 선언한다.16진수는 알파벳 포함이라 알파벳의 2진수를 외우는게 편함 - a : 1010 기준 - b : 1011 - c: 1100 기준 - d: 1101 - e: 1110 기준 - f: 1111예) 11111010 편의를 위해 뒤에서부터 4개씩 끊어간다 1111 1010 f a 0xfa 110101 여기서 뒤에서 부터 4개씩 자르고 남는 공간은 0을 넣어줌 0011 0101 0x 3 5 0x35 123456710111110110 0 101 1111 0110 5 f 6 0x5f6 16진수 &gt; 2진수 12345678예) 0x5f6 5 f 6 0101 1111 0110 제일 앞이 0이니까 없에고 10111110110 3. 산술연산컴퓨터에서 계산을 담당하는 곳을 alu라고 한다. 이곳은 2진수로 계산이 진행된다. alu은 더하기(adder)만 가능해서 빼기, 곱하기, 나누기를 하기 위해선 일련의 과정이 필요하다. 12345678910111213141의보수: 반전시켜줌2의보수: 1의 보수 + 1빼기 무조건 8자리로 맞춰줌 더하기뿐이 못하니까 양수 - 양수 = 양수 + (음수) 양수를 음수로 만들어주는 과정이 필요함 53 5 + 4 + 2 + 0 00110101 - 31 4 + 3 + 2 + 1 + 0 00011111 1보수 11100000 2보수 11100001 1234567891011 00110101 + 11100001 1000101108자리 넘어가면 버리기 000010110 앞에 0 다 날리고 10110 4321010진수로 변환 16 + 0 + 4 + 2 + 0 22","link":"/2019/04/17/til-20190417/"},{"title":"Insertion Sort","text":"파이썬 수업 자바스크립트로 정리중Insertion Sort123456789101112def insertion_sort(li): n=len(li) for i in range(1, n): temp=li[i] for j in range(i-1, -2, -1): if j==-1: break if li[j] &gt; temp: li[j+1]=li[j] else: break li[j+1]=temp","link":"/2019/04/24/til-20190424/"},{"title":"Merge Sort","text":"파이썬 수업 자바스크립트로 정리중Merge Sort123456789101112131415161718192021222324252627282930313233343536def merge(li, start, mid, end): merged=[] left=start right=mid+1 while left &lt;= mid and right &lt;= end: if li[left] &lt; li[right]: merged.append(li[left]) left+=1 else: merged.append(li[right]) right+=1 while left &lt;= mid: merged.append(li[left]) left+=1 while right &lt;= end: merged.append(li[right]) right+=1 li[start : end+1]=merged #for idx in range(start, end): # li[idx]=merged.pop(0) # merge_sort는 쪼게기만 함 정렬은 merge가def merge_sort(li, start, end): if(start &gt;= end): return mid=(start+end)//2 merge_sort(li, start, mid) merge_sort(li, mid+1, end) merge(li, start, mid, end)","link":"/2019/04/25/til-20190425/"},{"title":"프론트엔드와 자바스크립트","text":"1. 프론트엔드 개발자가 웹 퍼블리셔 다른점서버와 관계가 밀접하고 동적으로 웹페이지를 만든다. 2. 웹 어플리케이션과 어플리케이션 2.1. 웹 어플리케이션 브라우져를 이용하여 접속하여, 별도의 프로그램이 필요하지 않다. 웹 브라우져로 구동이 되기 때문에, 웹 브라우져를 잘 알아야한다. 2.2. 어플리케이션 실행파일이 따로 존재해, 다운로드를 받아야한다. 웹 브라우져로 접속이 필요없다. 3. UI(user interface) 애플리케이션을 사용하는 사람(유저)이 애플리케이션과 소통하기 위한 창구(user interface)를 사용하기 좋게 구현한다.(커뮤니케이션) 상태 정보를 서버로 전송하기도 하고, 서버의 데이터를 가져와서 UI에 표시하기도 한다. 4. 초심가자 경험하는 어려움 책이나 수업의 내용이 무슨 말인지 하나도 모르겠다. 주변 개발자의 말을 알아 들을 수 없다. 배경 지식 : 기본적인 CS(컴퓨터공학)지식 + 개념(용어)에 대한 이해 어떻게 만들어야 할 지 감조차 오지 않는다. 문제 해결 능력 : 문제(해결과제)가 무엇인지 알아채는 능력 + Computational thinking(컴퓨터 입장에서 생각) + 알고리즘/자료구조 + 경험 *문제해결능력 = 해결 과제(문제/요구사항)의 명확한 이해 -&gt; 복잡함을 단순하게 분해 -&gt; 자료를 정하고 구분(modelling) -&gt; 순서에 맞게 행위 배열 초심자는 코딩보단, 전문용어를 배우는게 좋다. 4.1. 효율적인 프로그래밍 학습은 없다. 연습을 꾸준히 반복하는 만큼 성장한다. 라이브코딩 감상과 예제 단순 타이핑은 연습이 아니다. 자신의 능력을 살짝 넘어서는 도전을 지속적으로 시도하는 것이 연습니다. 시행차교(a.k.a.삽질)은 “무엇을 알고 무엇을 모르는지”를 알게하는 개발자의 벗이자 선생님이다. 무엇을 모르는지 알았다면 몰랐던 것을 알기위해 “시도하고 실패하는 의식적인 연습을 반복” 한다. 하지만 모르는 것이 너무 많다. 베이스가 되는 것부터 구체적인 목표를 수립하고 학습하고 작은 성취를 반복하자. 수박 겉핥기식 학습도 문제지만 본질에서 벗어난 학습도 문제다. 피드백에 겸손하고 적극적으로 반응하여 행동을 교정하라. 5. 프로그래밍이란? 순서에 맞게 위에서 아래로 실행된다. 5.1. 프로그래밍언어란? 프로그래밍을 하기위한 언어이다. 컴퓨터와 커뮤니케이션을 하기 위한 언어이다. 5.2. HTML &amp; CSS 선언형 프로그래밍 언어이다. 미리 만들어 놓은 태그와 속성을 사용한다. 6. 코딩을 잘한다? 예전 : 메모리가 비싸서 가장 덜 쓰고 성늘을 높히는 것 현재 : 사람이 읽을때 쉽게 읽을 수 있게한다.(가독성을 좋게한다) 7. 개발자와 컴퓨터가 공통으로 알고 있는 언어javascript는 엔진을 통해 컴퓨터에게 언어를 습득하게 한다. 7.1. JavaScript7.1.1. ecmascript(core javascript) + api(환경에 따라 다름) 7.1.2. interpreter language 한줄 한줄 동시통역처럼 컴퓨터에게 바이트 코드를 만들어준다. 예전에는 느렸지만 google의 v8엔진 도입으로 속도가 비약적으로 빨라졌다. 웹브라우저에서 돌아가는 유일한 언어이다.(HTML &amp; CSS 도 같이) 7.1.3. JavaScript를 실행할 수 있는 환경 브라우저 ecmascript + web api(브라우저가 제공한다) 클라이언트 사이드에서 사용한다. node.js 환경 ecmascript + node.js api 서버 사이드에서 사용한다. v8 엔진을 내장한다. 파일 컨트롤이 가능하며, 서버에서 직접 관리가 가능하다. 오늘 알아야 할 것 ecmascript와 javascript가 무엇인가? wep api가 무엇인가?","link":"/2019/04/29/til-20190429/"},{"title":"엄청난 개발자가 되려면 알아야할 컴퓨터 공학","text":"엄청난 개발자가 되려면 알아야 할 컴퓨터 공학 자료구조선형 자료구조 stack queue linked list 비선형 자료구조 Tree (이진 트리) tree에 대한 이산수학 순회 DFS, Stack (재귀로 구현(stack frame), 반복문으로 stack) 전위 preorder 중위 inorder 후위 postorder BFS 레벨 순서levelorder BST (Binary Search Tree): Search가 최악의 경우 O(n), 대안으로 균형 이진 트리 균형 이진 트리 (Balanced Tree, Self balancing) AVL 트리 RED-BLACK 트리 B-Tree (데이터베이스의 인덱스) 균형 이진 트리 + 하드웨어 아키텍쳐 Heap (완전 이진트리): 일반적으로 배열로 구현한다. Hash (해시) Hash Table(map) Hash function collision(충돌) chaining (체이닝) open-addressing 기법 Graph (그래프) 순회 DFS: 깊이 우선 탐색 (stack 기반) BFS: 너비 우선 탐색 (queue 기반) MST(Minimum Spanning Tree): 최소 신장 트리, greedy 알고리즘 기반 kruslcal algorithm prim algorithm 최단 경로 문제 (shortest path) Dijkstra algorithm Bellman-ford algorithm floyd-warshall algorithm =&gt; Dynamic Programming","link":"/2019/04/26/til-20190426/"},{"title":"웹 브라우저, 변수","text":"1. 웹 브라우저 1. 1. 웹 브라우저는 어떻게 동작하는가? 웹 페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시한다. 브라우저는 서버로부터 HTML, CSS, 자바스크립트, 이미지 파일 등을 응답 받는다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다. 1.1. HTTP서버와 브라우저간의 통신규약을 말한다. 1.1.1. HTTP 1.x version 통신과정 Initial Request(https://www.naver.com)와 Response(index.html) Request(Get/CSS)와 Response(CSS) Request(Get/JavaScript)와 Response(JavaScript) 1.1.2. HTTP 2.x version 통신과정 한번의 Request로 필요한 Response를 다 받는다. 1.2. Request 와 Response브라우저가 서버에 Initial Request(https://www.naver.com) 를 보내면 서버는 브라우저에 Response(index.html, 다운로드)를 보내준다. 다운로드패킷단위로 쪼개진 2진수를 케이블을 통해 보낸다. PasingResponse받은 파일(텍스트로 되어있는 소스코드(html))을 브라우저가 이해하기 위해 해석한다. DOM(DOM Tree)HTML 파일을 읽어 pasing 한 결과. CSSOM(씨쏨트리)CSS를 읽어 pasing 한 결과. Render TreeDOM과 CSSOM을 합친(merge) 결과. Sysntax TreeJavaScript 가 pasing 된 결과로, DOM tree와 CSSOM tree 가 완성되어있어야 적용이 가능하다. Rendering Engine(브라우저)HTML과 CSS의 처리를 담당한다. JavaScript Engine(브라우저)JavaScript의 처리를 담당한다. 1.3. AST(Abstract Syntax Tree)문자열로 이루어진 자바스크립트 코드를 해석하기 위한 일련의 과정. 토크나이징(Tokenizing) 문자열로 이루어진 소스 코드를 토큰(코드의 최소 단위)들로 분리한다. 파싱(Pasing) 토큰들의 집합을 구문 분석하여 AST를 생성한다. 코드 실행 생성된 AST는 복잡한 과정을 통해 바이트 코드 또는 머신 코드로 변환되어 인터프리터에 의해 실행된다. 일단은 알아두자 식별자들의 모임이 실행컨텍스트에 렉시컬 환경에 들어있다. 자바스크립트엔진은 텍스트가 들어오면 토큰으로 나눠 문법에 맞으면 실행시킨다. version 표시ver 10.1.2 마지막 자리(2) 버그 fix를 수정한다. 두번째 자리(1) 기능향상을 한다. (minor버전) 첫번째 자리(10) 버젼업을 한다. (major버전, Break Change가 있는지 확인해야한다.) Break Change : 전버젼과 호환이 안된다. ver 10.0.2와 ver 10.100.32 는 호환이 가능하다. 2. 변수 2.1. 변수는 무엇인가, 왜 필요한가?변수(variable)는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 간단히 말하자면 변수는 값을 저장하고 참조하는 메커니즘으로 값에 이름을 붙인 것이다. 만약 변수가 없다고 가정해보자. 숫자값 10과 20의 연산 결과 값 30은 임의의 메모리 주소에 할당된다. 이 결과 값을 한 번만 사용한다면 상관없다. 하지만 재사용하기 위해선 주소값을 알아야 참조를 하는데 주소값에 직접적인 접근이 불가해 메모리 공간에 변수라는 이름을 선언해주는 것이다. 2.2. 변수 선언변수 선언(variable declaration)이란 변수명(식별자)을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다. 변수를 선언할 때는 var, let, const 키워드를 사용한다. 자바스크립트 엔진은 변수 선언 후 변수 값을 할당하지 않으면 undefined라는 값을 암묵적으로 할당해 초기화 한다. 선언 단계(Declaration phase)변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계(Initialization)값을 저장하기 위해 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. 할당변수에 값을 저장하는 것. 참조변수에 저장된 값을 읽어 들이는 것. 선언변수명(식별자)을 등록하여 자바스크립트 엔진에 존재를 알리는 것. 정의식별자의 정체를 알리는 것 평가값과 값을 연산하는 행위. 실행값과 값을 비교하는 행위. cell(셀)메모리의 1byte를 1개의 셀이라한다. 한개의 셀에는 한개의 아스키코드를 담을 수 있다. ReferenceError식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 참조 에러다.(변수를 사용하려면 반드시 선언이 필요하다.) 중간 중간 용어 알기 네스팅(중첩) 태그의 부자관계는 네스팅으로 표현한다. 메타데이터 컴퓨터에게 주는 데이터로, HTML의 head 에 쓰는 화면에 안보이는 내용이 들어갈 수 있다. 룰셋 (CSS) 선택자와 속성의 뭉텅이","link":"/2019/05/01/til-20190501/"},{"title":"변수, 데이터 타입, 값, 리터럴","text":"1. 변수변수(Variable)는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 1.1. 변수 선언의 차이12// 할당할 때 변수의 데이터 타입을 알 수 있다.var a; 12// 변수선언을 할 때 데이터 타입을 명시한다.int a; TypeScriptJavaScript에 정적타입언어를 사용한다. 1234567// 변수 선언과 undefined 초기화를 해준다.var x;// 변수 할당문, 우변의 값을 좌변에 할당한다.x = 100;console.log(x); 원시타입 : 변경이 불가능하다. 객체타입 : 변경이 가능하다. 1.2. 변수 선언의 실행 시점과 변수 호이스팅변순 선언은 런타임 이전에 실행된다. 이것을 변수 호이스팅이라 말한다. 2. 데이터 타입통상적인 자바스크립트 엔진은 숫자를 8byte 로 처리한다. 2.1. 왜 데이터 타입이 필요한가?값을 참조할 때 가장 선두 주소를 찾아 가는데 선두 주소로 부터 몇 바이트 단위로 가져오는지 알아야 하기 때문이다. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 3. 값값은 더이상 평가할 수 없는 하나의 표현식이다.표현식은 값을 생성하는 문이다. 123// 10 + 20 은 표현식이다. 이 표현식은 평가되어 30이라는 값을 만든다.// 10은 평가해도 10이고, 20을 평가해도 20이다.10 + 20 우변은 하나의 값이 올자린데 표현식으로 되어 있어서 표현식을 평가해 값으로 할당한다. 4. 값의 생성값은 다양한 방법(표현식)으로 생성할 수 있다. 가장 기본적인 방법은 리터럴 표기법을 사용하는 것이다. 4.1. 리터럴리터럴은 소스 코드 안에서 직접 만들어 낸 고정된 값 자체를 말한다. 좀 더 명확히 말하면 리터럴은 자바스크립트 엔진에 의해 값으로 평가된다. 리터럴은 리터럴 표기법으로 생성한다. 값을 만드는 방법은 리터럴 표기법(리터럴 표현식)을 사용한다. 12// 10과 20은 리터럴 표현식이다. 30은 리터럴 표현식으로 평가된 값이다.10 + 20 = 30 리터럴은 값이고, 값은 리터럴이 아니다. 평가되기 이전의 값을 리터럴이라고 한다. 4.2. 표현식값은 다양한 방법으로 생성할 수 있다. 표현식(expression)은 리터럴, 식별자, 연산자, 함수 호출 등의 조합을 말한다. 표현식은 평가(evaluation, 표현식을 해석하여 하나의 값을 만드는 과정)되어 하나의 값을 만든다. 즉, 표현식은 하나의 값으로 평가될 수 있는 문(statement)이다. 5. 숫자 타입1234// 숫자 타입의 3가지 특별한 값console.log(10 / 0); // Infinityconsole.log(10 / -0); // -Infinityconsole.log(1 * 'String'); // NaN(숫자가 아니다) 6. 문자열 타입문자열은 0개 이상의 유니코드들의 집합으로 전세계 대부분의 문자를 표현할 수 있다. 문자열은 작은 따옴표(‘’), 큰 따옴표(“”) 또는 백틱(``) 안에 텍스트를 넣어 생성할 수 있다. 7. 동적 타입 언어와 변수 7.1. 변수 사용시 주의해야 할 사항 변수의 사용을 적극적으로 줄인다. 변수의 개수가 많으면 많을수록 오류가 발생할 확률은 높아진다. 전역 변수는 사용하지 않는다. 변수의 생명주기를 최대한 짧게 만든다. 변수보다는 상수를 사용해 값의 변경을 억제한다. 변수명은 변수의 존재 이유를 파악할 수 있도록 명명한다. 8. 연산자 8.1. 표현식과 연산자표현식은 하나의 값으로 평가될 수 있는 문(표현식 문, expression statement)이다. 값을 만드는 방법은 리터럴과 표현식이 있다. 8.2. 문과 표현식문(statement)은 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령이다. 표현식인 문 : 값으로 평가된다. 변수에 할당할 수 있다. 표현식이 아닌문 : 값으로 평가되지 않는다. 변수에 할당할 수 없다.(변수선언, 함수정의, if문(제어문)) 8.3. 비교 연산자 삼항연산자 삼항연산자는 표현식이고 if문은 표현식이 아닌문이다.","link":"/2019/05/03/til-20190503/"},{"title":"예습, 러버덕, 기초 알고리즘","text":"아침 러버덕 변수 하나의 값은 사용자가 재사용을 필요로 할 수도 있다. 이 때 값이 저장되어 있는 메모리 주소를 직접 연결하지 않고 메모리 주소를 식별하기 위해 붙인 이름이다. 변수 선언 변수의 존재를 자바스크립트 엔진에 알려 관리하도록 하는 것 할당 새로운 메모리에 값이 저장된 후 변수가 그것을 가리키는 행위 식별자 값을 구별할 수 있는 고유한 이름 정의 식별자의 정체를 알리는 것, 자바스크립트에서는 정의와 동시에 할당이 일어난다. 기초 알고리즘 문자열 s와 자연수 n을 입력받아, 만약 s의 길이가 n보다 작으면 s의 왼쪽에 공백으로 추가해서 길이가 n이 되게 만든 후 반환하고, 아니면 s를 그대로 반환하는 함수를 작성해보세요. 123456789101112function leftPad(str, num){ str_split = str.split(''); if(str.length &lt; num){ for(var i = 0; i &lt; num-str.length; i++){ str_split.unshift(' '); } return a = str_split.join(''); } else{ return str; }} 두 문자열을 입력받아, 대소문자를 구분하지 않고(case insensitive) 두 문자열이 동일한지를 반환하는 함수를 작성하세요. 1234567function insensitiveEqual(a, b){ if(a == b){ return true; } else{ return false; }} 문자열을 입력받아, 문자열 안에 들어있는 모든 모음(a, e, i, o, u)의 갯수를 반환하는 함수를 작성하세요. 1234567891011var j = 0;for(var i = 0; i &lt;= arry.length; i++){ if(arry[i]==='a'|| arry[i] === 'e' || arry[i] === 'i' || arry[i] === 'o' || arry[i] === 'u'){ j++ } return j;} 1. 동적 타이핑 1.1. 동적 타입 언어와 정적 타입 언어자바스크립트의 모든 값은 데이터 타입을 갖는다. 그렇다면 변수는 데이터 타입을 갖을까? C나 Java와 같은 정적 타입(Static / Strong type) 언어는 변수를 선언할 때 변수의 데이터 타입을 사전에 선언해야 한다. 12345// 변수 c에는 1byte 정수 타입의 값(-128 ~ 127)만을 할당할 수 있다.char c;// 변수 num에는 4byte 정수 타입의 값(-2,124,483,647 ~ 2,124,483,647)만을 할당할 수 있다.int num; 정적 타입 언어는 변수의 타입을 변경할 수 없으며 변수에 선언한 타입에 맞는 값만을 할당할 수 있다. 이를 통해 타입의 일관성을 강제하여 보다 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다. 자바스크립트는 정적 타입 언어와는 다르게 변수를 선언할 때 타입을 선언하지 않는다. 다만 var,let, const 키워드를 사용해 변수를 선언할 뿐이고, 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 1234567891011121314151617181920212223242526var foo;console.log(typeof foo); // undefinedfoo = 3;console.log(typeof foo); // numberfoo = 'Hello';console.log(typeof foo); // stringfoo = true;console.log(typeof foo); // booleanfoo = null;console.log(typeof foo); // objectfoo = Symbol(); // 심볼console.log(typeof foo); // symbolfoo = {}; // 객체console.log(typeof foo); // objectfoo = []; // 배열console.log(typeof foo); // objectfoo = function () {}; // 함수console.log(typeof foo); // function 자바스크립트의 변수는 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있으므로 정적 타입 언어에서 말하는 데이터 타입과 개념이 다르다. 정적 타입언어와 동적타입언어의 차이는 변수의 타입이 결정되고 변수의 타입을 변경할 수 있냐 없냐에 있다. 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다.","link":"/2019/05/02/til-20190502/"},{"title":"제어문, 반복문, 조건문, 타입변환, 단축평가, 객체 리터럴","text":"1. 제어문제어문은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 가급적 if문과 for문의 사용을 지양해야한다. 실무에서는 for문을 대신해 함수를 사용하거나 for…in 등을 사용한다. 1.1. 블록문블록문은 중괄호로 묶은 것으로 블록 또는 코드블록이라고 부르기도 한다. 같이 실행되는 집합으로 본다. 블록문의 끝에는 세미콜론을 붙이지 않는다. 12345// 블록문{var x = 100;console.log(x);} 2. 조건문조건문은 주어진 조건식(블리언 값으로 평가될 수 있는 표현식)의 결과에 따라 코드 블럭의 실행을 결정한다. 2.1. if…else 문주어진 조건식의 평가 결과에 따라 실행할 코드 블록을 결정한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 강제로 변환되어 논리적 참, 거짓을 구별한다.(블리언 값) 1234567if(조건식1){ // 조건식1이 참이면 실행한다.} else if(조건식2){ // 조건식1이 거짓으로 판명나 건너 뛰고 조건식2가 참이면 실행한다.} else{ // 모든 조건식이 거짓이면 실행한다.} 2.2. switch 문주어진 표현식을 평가하여 그 값과 일치하는 case문으로 이동하여 코드 블럭을 실행한다. if…else문은 불리언 값으로 평가되지만 switch 문의 표현식은 문자열, 숫자 값인 경우가 많다. break가 없으면 실행된 후 탈출하지 않고 break를 만날 때까지 모두 실행한다. 이것을 폴스루(fall through)라 한다. 12345678910switch(표현식){ case 표현식1: // 표현식과 표현식1이 일치하면 실행한다. break; // 이 블록이 실행되고 문을 탈출한다. case 표현식2: // 표현식과 표현식2가 일치하면 실행한다. break; default: // 표현식과 일치하는 case가 없을 때 실행한다.} 3. 반복문반복문은 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 검사하여 여전히 참인 경우 코드 블록을 실행한다. 3.1. for 문for문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다. 123456789for (변수 선언문 또는 할당문; 조건식; 증감식) { 조건식이 참인 경우 반복 실행될 문;}for(var i = 0; i &lt; 2; i++){ console.log(i);}// 결과 : 0 1 3.2. while 문while 문은 주어진 조건식의 평가 결과 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 종료한다. 123456789var count = 0;// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.while (count &lt; 3) { console.log(count); count++;} // 결과 : 0 1 2 4. 타입 변환 4.1. 타입 변환이란?개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환이라 하고, 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 타입 변환이 되는 것을 암묵적 타입 변환이라 한다. 123456789101112131415161718192021222324// 문자열 타입 변환 var x = 10; // 명시적 타입 변환 var str1 = x.toString(); // '10' // 암묵적 타입 변환 var str2 = x + ''; // '10'// 숫자 타입 변환 var x = '10'; // 명시적 타입 변환 var num1 = Number(x); // 10 // 암묵적 타입 변환 var num2 = +x; // 10// 블리언 타입 변환 var num = 1; var str = '0'; // 명시적 타입 변환 var boo1 = Boolean(num); // true var boo1 = Boolean(str); // false // 암묵적 타입 변환 var boo2 = !!num; // true var boo2 = !!str; // false 5. 단축 평가논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자의 연산 결과는 불리언 값이 아닐 수도 있다. 이 두 연산자는 언제나 피연산자 중 어느 한쪽 값을 반환한다. 논리합 연산자는 두개의 피연산자가 모두 true로 평가될 때 true로 반환한다. 1234// 논리합 연산자'Cat' &amp;&amp; 'Dog' // 'Dog'false &amp;&amp; 'Dog' // false'Cat' &amp;&amp; false // false 논리곱 연산자는 두개의 피연산자 중 하나만 true로 평가되도 true를 반환한다. 1234// 논리합 연산자'Cat' || 'Dog' // 'Cat'false || 'Dog' // 'Dog''Cat' || false // 'Cat' 6. 객체 리터럴객체를 만드는 방법은 객체 리터럴이다. 원시 값은 변경 불가능한 값(immutable value)이지만 객체는 변경 가능한 값(mutable value)이다. 자바스크립트의 객체는 키(key)와 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 프로퍼티의 동작을 나타내는 것은 메소드(Method)라고 한다. 프로퍼티는 키와 값으로 구성되어 있다. 대상 객체에 관심있는 것만 나열하는 작업을 추상화라고 한다. 객체는 데이터를 의미하는 프로퍼티와 데이터를 참조하고 조작할 수 있는 동작을 의미하는 메소드로 구성된 집합이다. 6.1. 프로퍼티객체는 프로퍼티들의 집합이며 프로퍼티는 키와 값으로 구성된다. 그중에 프로퍼티 값이 함수인 경우를 메소드라 부른다. 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol값 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 프로퍼티 키 네이밍을 할 때 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다. 1234567var sungjin = { name: 'choisungjin', age: 25, // 규칙을 따름 'w-o-w': 'hoooo' // 규칙을 따르지 않음}console.log(sungjin); // {name: 'choisungjin, age: 25'} 6.2. 프로퍼티 접근12345678910var sungjin = { name: 'choisungjin'};// 마침표 표기법console.log(person.name); // choisungjin// 대괄호 표기법// 네이밍 규칙을 지키지 않은 경우 무조건 대괄호 표기법 사용console.log(person['name']); // choisungjin 6.3. 프로퍼티 값 갱신이미 있는 키에 값을 할당하면 갱신된다. 12345678var sungjin = { age: 20};// person객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신된다.sungjin.age = 24;console.log(sungjin); // {age: 24} 6.4. 프로퍼티 동적 생성존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다. 1234567var sungjin = { age: 24};sungjin.name = 'ChoiSungJin';console.log(sungjin); // {age: 24, name: 'ChoiSungJin'} 6.5. 프로퍼티 삭제delete 연산자를 사용해 객체의 프로퍼티를 삭제한다. 12345678var sungjin = { age: 24, name: 'ChoiSungJin'};delete sungjin.age;console.log(sungjin); // {name: 'ChoiSungJin'} 6.6. 프로퍼티 키 동적 생성프로퍼티의 키를 동적으로 생성할 수 있다. 123456789101112// ES6const prefix = 'prop';let i = 0;// 내부에서 프로퍼티 키 동적 생성var obj = { [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i};console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}","link":"/2019/05/07/til-20190507/"},{"title":"러버덕, 별찍기","text":"아침 러버덕 함수란 무엇인가? 일련의 과정을 문들로 구현하고 코드블록으로 감싸서 일괄적으로 실행한다. 원시타입과 참조타입(불변 / 가변) 원시타입은 값을 저장하고, 참조타입은 참조 값을 저장한다. immutable vs mutable 재할당을 이외의 방법으로 값을 변경할 수 있다.(가변) 함수 선언문 / 표현식의 차이는? 함수 선언문은 선언과 동시에 할당이 이루어짐(함수 호이스팅) 함수 표현식은 선언만 됨 (변수 호이스팅) 콜백은 무엇이고 어떻게 활용되는가? 일급객체이므로, 함수를 인수로 전달한다. 외부에서 내부로 전달한다. 헬퍼함수이다. 별찍기 과제12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// pattern 1// *// **// ***// ****// *****let sum = '';for (let i = 1; i &lt;= 5; i++) { for (let j = 1; j &lt;= i; j++) { sum += '*'; } sum += '\\n';}console.log(sum);// pattern 2// *****// ****// ***// **// *let sum = '';for (let i = 1; i &lt;= 5; i++) { for (let k = 1; k &lt; i; k++) { sum += ' '; } for (let j = 1; j &lt;= 5 - i + 1; j++) { sum += '*'; } sum += '\\n';}console.log(sum);// pattern 3// *****// ****// ***// **// *var sum = '';for (let i = 1; i &lt;= 5; i++) { for (let j = 1; j &lt;= 5 - i + 1; j++) { sum += '*'; } sum += '\\n';}console.log(sum);// pattern 4// *// **// ***// ****// *****let sum = '';for (let i = 1; i &lt;= 5; i++) { for (let k = 1; k &lt; 5 - i + 1; k++) { sum += ' '; } for (let j = 1; j &lt;= i; j++) { sum += '*'; } sum += '\\n';}console.log(sum);","link":"/2019/05/09/til-20190509/"},{"title":"러버덕, 변수의 생명주기, 키워드, 생성자 함수","text":"아침 러버덕 스코프 / 블록스코프 / 함수 스코프 식별자의 유효범위 / var는 블록레벨 스코프를 지원하지 않고, 함수 레벨 스코프만 지원한다. 스코프 체인이란 무엇이고, 지역 스코프가 변수를 찾아나가는 과정은? 스코프가 계층적 구조로 연결되어 있는 것, 본인의 스코프를 기준으로 상위 스코프 방향으로 이동하며 선언된 변수를 찾는다. 동적 스코프 / 정적 스코프(렉시컬 스코프) 함수를 어디서 호출 / 정의 했는지에 따라 함수의 상위 스코프를 결정한다. 다음 코드가 어떻게 동작하고, 왜 그렇게 동작하는지?(암묵적 전역변수) 123456function foo(){ x = 10;}foo();console.log(x); function foo()안에서 선언된 암묵적 전역변수인 x는 함수 스코프를 지원하지 않는다. 1. 변수의 생명주기 1.1. 지역 변수의 생명 주기변수는 선언과 할당을 통해 값을 갖고,언젠가 소멸한다. 12345678function foo() { var x = 'local'; console.log(x); // local return x;}foo();console.log(x); // ReferenceError: x is not defined 1.2. 전역 변수의 생명 주기전역 변수는 윈도우의 프로퍼티로 존재해 사라지지 않는다. 1.3. 전역 변수의 문제점 1.3.1. 암묵적 결함모든 코드가 전역 변수를 참조하고 변경할 수 있다. 변수의 유효 범위가 크면 위도치 않게 상태가 변경될 수 있는 위험성도 있다. 1.3.2. 긴 생명 주기전역 변수는 생명 주기가 길다. 때문에 변수명이 중복되어 재 할당이 이루어질 수도 있다. 1.3.3. 스코프 체인 상에서 종점에 존재전역 변수는 항상 스코프 체인의 최상위에 있기 때문에 전역 변수의 검색 속도가 가장 느리다. 1.3.4. 네임 스페이스 오 렴파일이 분리되어 있어도 하나의 전역 스코프를 공유한다. 1.4. 전역 변수 사용 억제 방법전역 변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역 변수를 사용하여야 한다. 변수의 스코프는 좁을수록 좋다. 1.4.1. 모듈 패턴 ( 꼭 공부)함수는 할당될 때 부터 상위 스코프를 가지고 있다. 중첩함수가 외부함수보다 오래 살아남는다.(클로져) 12345678910111213141516171819202122var Counter = (function () { // private 변수 var num = 0; // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다. return { increase() { return ++num; }, decrease() { return --num; } };}());// private 변수는 외부로 노출되지 않는다.console.log(Counter.num); // undefinedconsole.log(Counter.increase()); // 1console.log(Counter.increase()); // 2console.log(Counter.decrease()); // 1console.log(Counter.decrease()); // 0 2. 키워드(var, let, const) ES6를 사용한다면 var키워드는 사용하지 않는다. 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 재할당이 필요 없을 경우 const키워드를 사용한다. 2.1. var 중복 선언이 가능하다 함수 레벨 스코프만 지원한다. 변수 호이스팅이 일어난다. 2.2. let 중복 선언이 불가능한다. 블록 레벨 스코프를 지원한다. 변수 호이스팅이 일어나지 않는 것처럼 동작한다. 2.3. const 모든 점이 let과 거의 흡사하지만 하나 다른 것이 있다. 재할당이 금지된다.(선언과 동시에 할당이 이루어져야 한다.) 3. 프로퍼티 정의 3.1. 용어 알기 데이터 프로퍼티 : 값이 있다. 다른 데이터 프로퍼티의 값을 조절한다.(함수) 접근자 프로퍼티 : 값이 없다. 4. 생성자 함수에 의한 객체 생성 4.1. Object 생성자 함수자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 빌트인(intrinsic 내장) 생성자 함수를 제공한다. 1234567const obj = new Object('hello'); // 문자열 객체를 만든다obj.a = 1;obj.b = 10;console.log(Object()); // {}console.log(new Object()); // {} 기본적인 문법 new 사용 인스턴스(instance) 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어이다. 생성자 함수도 객체이기 때문에 생성자 함수나 클래스가 생성한 객체를 다른 객체와 구분하기 위해 인스턴스라고 부른다. 4.2. 생성자 함수생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 123456789101112131415// 생성자 함수function Circle(radius) { // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// 인스턴스의 생성const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20","link":"/2019/05/10/til-20190510/"},{"title":"API사용 연습문제","text":"1. Math.PI양수를 입력받아 이 수를 반지름으로 하는 원의 넓이를 반환하는 함수를 작성하세요. 12345function circleArea(n) { return (n ** 2) * Math.PI;}console.log(circleArea(10)); // 314.1592653589793 2. Math.random두 정수 min, max 를 입력받아, min 이상 max 미만인 임의의 정수를 반환하는 함수를 작성하세요. 1234567function minToMax(min, max) { const sub = max - min; return Math.floor((Math.random() * sub) + min);}console.log(minToMax(2, 8)); // 2 ~ 7 중 랜덤의 수 3. Math.ceil정수를 입력받아, 5 단위로 올림한 수를 반환하는 함수를 작성하세요. 1234567891011121314151617181920212223// 처음 생각한 방법function ceilBy5(n) { const i = 1; while ((n % 5) !== 0) { n += i; } return n;}console.log(ceilBy5(30)); // 30console.log(ceilBy5(32)); // 35console.log(ceilBy5(37)); // 40// 강사님의 의도function ceilby5(num) { return Math.ceil(num / 5) * 5;}console.log(ceilBy5(30)); // 30console.log(ceilBy5(32)); // 35console.log(ceilBy5(37)); // 40 4. toString임의의 HTML 색상 코드를 반환하는 함수를 작성하세요. 12345678910111213141516171819202122232425262728293031323334353637383940414243// 처음 생각한 방법function hexNumber() { return Math.floor(Math.random() * 10);}function hexString() { return String.fromCharCode(Math.floor((Math.random() * 5) + 65));}function random() { return Math.floor(Math.random() * 2);}function htmlHexCode() { let result = '#'; for (let i = 0; i &lt; 6; i++) { const reload = [hexNumber(), hexString()]; result += reload[random()]; } return result;}console.log(htmlHexCode()); // #92F01Aconsole.log(htmlHexCode()); // #00FF12// 강사님의 의도function htmlHexCode() { let result = '#'; for (let i = 0; i &lt; 6; i++) { result += Math.floor(Math.random() * 16).toString(16); } return result.toUpperCase();}console.log(htmlHexCode()); // #92F01Aconsole.log(htmlHexCode()); // #00FF12 5. Math.random() * numberrgb색상코드를 랜덤으로 반환하는 함수를 작성하세요. 1234567891011function randomRgbCode() { function randomNumber() { return Math.floor(Math.random() * 256); } return `rgb(${randomNumber()}, ${randomNumber()}, ${randomNumber()})`;}console.log(randomRgbCode()); // rgb(123, 44, 254);console.log(randomRgbCode()); // rgb(12, 3, 223); 6. String.substring, String.indexOf소수인 숫자와, 자릿수를 받아서 소수를 자리수만큼만 자른 뒤 반환하는 함수를 작성하세요. 123456789function fixFloat(num, a) { const str = num + ''; return str.substring(0, str.indexOf('.') + a + 1);}fixFloat(10.12345, 2); // 10.12fixFloat(15.5678, 1); // 15.5 7. String.replaceCamel case의 문자열을 입력받아, snake case로 바꾼 새 문자열을 반환하는 함수를 작성하세요. 1234567891011121314function camelToSnake(str) { let i = 0; while (str[i] !== str[i].toUpperCase()) { i += 1; } const newStr = str.replace(str[i], `_${str[i]}`); return newStr.toLowerCase();}console.log(camelToSnake('helloWorld')); // 'hello_world'","link":"/2019/05/16/til-20190516/"},{"title":"배열 고차 함수","text":"1. 배열 고차 함수함수를 인수로 받거나, 함수를 리턴하면 고차함수라 한다. 고차함수는 외부 상태 변겅이나 가변 데이터를 피하고 불변성을 지향한다.함수형 프로그래밍은 클로저가 중요하다. 12345678function makeCounter(predicate) { let num = 0; return function () { // 상위 스코프는 makeCounter이다. num = predicate(num); return num; };} 상위스코프의 결정은 정의와 동시에 이루어 진다. 이를 렉시컬스코프라 한다. 1.1. Array.prototype.sort1234567891011121314151617181920212223242526272829303132333435363738const points = [40, 100, 1, 5, 2, 25, 10];// 오름차순 정렬fruits.sort();// 내림차순 정렬fruits.sort().reverse();// 숫자 배열 오름차순 정렬points.sort(function (a, b) { return a - b; });// 숫자 배열 내림차순 정렬points.sort(function (a, b) { return b - a; });// 객체 정렬const todos = [ { id: 4, content: 'JavaScript' }, { id: 1, content: 'HTML' }, { id: 2, content: 'CSS' }];// 비교 함수function compare(key) { return function (a, b) { // 프로퍼티 값이 문자열인 경우, - 산술 연산으로 비교하면 NaN이 나오므로 비교 연산을 사용한다. return a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0); };}// id를 기준으로 정렬todos.sort(compare('id'));console.log(todos);// content를 기준으로 정렬todos.sort(compare('content'));console.log(todos); 1.2. Array.prototype.forEach forEach의 리턴값은 undefined이다. for 문 대신 사용할 수 있고 for 문의 사용을 자제하고 forEach를 사용하는 게 좋다. 123456789101112const numbers = [1, 2, 3];let pows = [];// for 사용for (let i = 0; i &lt; numbers.length; i++) { pows.push(numbers[i] ** 2);}// forEach 사용numbers.forEach(function (item) { // 콜백함수의 파라미터로 요소값, 요소값의 인덱스, this pows.push(item ** 2);}); forEach 메소드의 두번째 인자로 this를 전달할 수 있다. 1234567891011121314function Square() { this.array = [];}Square.prototype.multiply = function (arr) { arr.forEach(function (item) { // this를 인수로 전달하지 않으면 this === window this.array.push(item * item); }, this); // 여기};const square = new Square();square.multiply([1, 2, 3]);console.log(square.array); // [ 1, 4, 9 ] 1.3. Array.prototype.map콜백 함수의 반환값으로 새로운 배열을 생성하여 반환한다. 이때 원본 배열은 변경되지 않는다. 들어갈 때 3개면 나올 때도 3개다. 12345678910111213const numbers = [1, 4, 9];const roots = numbers.map(function (item) { // 새로운 배열을 리턴하기 위해 변수를 선언해준다. return Math.sqrt(item); // return이 무조건 있어야한다. push와 동일한 역할을 한다.});// 위 코드의 축약표현은 아래와 같다.// const roots = numbers.map(Math.sqrt);// map 메소드는 새로운 배열을 반환한다console.log(roots); // [ 1, 2, 3 ]// map 메소드는 원본 배열은 변경하지 않는다console.log(numbers); // [ 1, 4, 9 ] 1.4. Array.prototype.filter콜백함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열을 반환한다. 들어갈 때 3개면 나올 때는 3개 이하이다. 123456const result = [1, 2, 3, 4, 5].filter(function (item, index, self) { console.log(`[${index}] = ${item}`); return item % 2; // 홀수만을 필터링한다 (1은 true로 평가된다) if와 같은 역할을 한다.});console.log(result); // [ 1, 3, 5 ] 1.5. Array.prototype.reduce하나의 값을 반환한다. 123456789101112131415161718192021222324252627const arr = [1, 2, 3, 4, 5];/*previousValue: 이전 콜백의 반환값currentValue : 배열 요소의 값currentIndex : 인덱스array : 메소드를 호출한 배열, 즉 this*/const sum = arr.reduce(function (previousValue, currentValue, currentIndex, self) { console.log(previousValue + '+' + currentValue + '=' + (previousValue + currentValue)); return previousValue + currentValue; // 결과는 다음 콜백의 첫번째 인자로 전달된다});console.log(sum); // 15: 1~5까지의 합/*1: 1+2=32: 3+3=63: 6+4=104: 10+5=1515*/const max = arr.reduce(function (prev, cur) { return prev &gt; cur ? prev : cur;});console.log(max); // 5: 최대값","link":"/2019/05/20/til-20190520/"},{"title":"러버덕, this, 연습문제","text":"아침 러버덕 일급객체의 조건은 무엇인가? 변수, 자료구조(객체, 배열 등) 할당할 수 있다. 매개변수에 전달할 수 있다. 함수의 반환값으로 사용할 수 있다. 무명의 리터럴로 생성할 수 있다. 프로토타입 기반 상속의 이점은 무엇인가?메소드의 중복을 제거하여 메모리 낭비를 막을 수 있다. ‘constructor’,‘prototype’, __proto__에 대해 설명해보세요 __proto__ : 인스턴스가 프로토타입에 접근하기 위한 접근자 프로퍼티이다. prototype : 생성자 함수에 접근하기 위한 프로퍼티이다. constructor : 컨스트럭터, 컨스트럭터는 생성자이다. 프로토타입 체인에 대해 설명해보세요 프로퍼티에 접근하기 위해서는 프로토타입 체인을 상위의 프로토타입을 따라 찾는다. 1. thisthis는 자신이 속한 객체를 가리키는 자기 참조 변수이다. this에 바인딩 되는 객체는 함수 호출 방식에 따라 변화하여 결정되고, 태초에 생겼을 때 전역(window)으로 초기화 돼있다. 1.1. 일반 함수 호출일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다. 12345678function foo() { this; // window function bar() { this; // window } bar();}foo(); 하지만 메소드 내에서 정의한 중첩함수, 콜백함수에 this가 전역 객체를 바인딩하는 것은 헬퍼함수로서의 문제가 있다. 때문에 this를 외부한수로 바인딩 해주어야 하는데 방법은 아래와 같다. 1234567891011121314151617181920212223var value = 1;const obj = { value: 100, foo() { // this 바인딩(obj)를 변수 that에 할당한다. const that = this; // 콜백 함수 내부에서 this 대신 that을 참조한다. setTimeout(function () { console.log(that.value); // 100 }, 100); // bind를 사용한 방법 // 인수는 함수 외부에서 넣어주는 것이다. setTimeout(function () { console.log(this.value); // 100 }.bind(this), 100); }};obj.foo(); 1.2. 메소드 호출메소드 내부의 this는 메소드를 호출한 객체에 바인딩된다. 12345678const person = { name: 'Choi', getName() { return this.name; // 아래에 메소드를 호출한 객체인 person이 바인딩된다. }};console.log(person.getName()); // Lee 1.3. 생성자 함수 호출생성자 함수 내부의 this는 생성자 함수가 미래에 생성할 인스턴스가 바인딩된다. 123456789101112function Person(name) { this.name = name; // 생성자 함수로 생설할 빈객체(인스턴스)를 가리킨다. this.sayHello = function () { return `안녕하십니까 ${this.name}입니다.`; };}const me = new Person('sungjin');const you = new Person('gyuha');console.log(me.sayHello()); // 안녕하십니까 sungjin입니다.console.log(you.sayHello()); // 안녕하십니까 gyuha입니다. 1.4. call / apply 정적 메소드는 this가 필요없다. 12345678// apply 사용법const arr = [1, 2, 3, 4, 5];// es5Math.max.apply(null, arr);// es6Math.max(...arr); 연습 문제 짝수와 홀수 evenOrOdd 함수는 정수 num을 매개변수로 받는다. num은 1이상의 정수이며, num이 음수인 경우는 없다. num이 짝수일 경우 ‘Even’을 반환하고 홀수인 경우 ‘Odd’를 반환하도록 evenOrOdd 함수를 완성하라. 단, if문을 사용한 답과 3항 연산자를 사용하는 답 두가지를 제시하여야 한다. 12345678910111213141516171819// if문function evenOrOdd(num) { if (num % 2 === 0) return 'Even'; return 'Odd';}console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even// 3항 연산자function evenOrOddd(num) { return num % 2 === 0 ? 'Even' : 'Odd';}console.log(evenOrOddd(2)); // Evenconsole.log(evenOrOddd(3)); // Oddconsole.log(evenOrOddd(1000)); // Even 1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라. 단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다. (hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n] 12345678910111213141516171819202122232425262728293031323334// 기존 방법// function getCount8() {// let count = 0;// for (let i = 1; i &lt;= 10000; i++) {// const num = i + '';// for (let j = 0; j &lt; num.length; j++) {// if (num[j] === '8') {// count += 1;// }// }// }// return count;// }console.log(getCount8()); // 4000// 강사님 제안function getCount8() { let count = 0; let str = ''; for (let i = 0; i &lt; 10000 + 1; i++) { str += i; } for (let j = 0; j &lt; str.length; j++) { if (str[j] === '8') count += 1; } return count;}console.log(getCount8()); // 4000 문자열 다루기 alphaString46 함수는 문자열 s를 매개변수로 입력받는다. s의 길이가 4 ~ 6이고, 숫자로만 구성되어 있는지 확인하는 alphaString46 함수를 완성하라. 예를 들어 s가 ‘a234’이면 false를 리턴하고 ‘1234’라면 true를 리턴한다. 1234567891011function alphaString46(s) { const result = isNaN(s) === false &amp;&amp; (s.length &gt; 3 &amp;&amp; s.length &lt; 7) ? true : false; return result;}console.log(alphaString46('1234')); // trueconsole.log(alphaString46('9014')); // trueconsole.log(alphaString46('723')); // falseconsole.log(alphaString46('a234')); // falseconsole.log(alphaString46('')); // falseconsole.log(alphaString46()); // false","link":"/2019/05/15/til-20190515/"},{"title":"러버덕, 연습문제","text":"아침 러버덕 this는 다음 상황에서 어떻게 바인딩 되는지 토의해 보세요. 함수의 호출 방식에 따라 this에 바인딩 되는 객체가 달라진다. this일반함수를 제외한 객체의 프로퍼티나 메소드를 참조하기 위한 자기참조 변수이다. 바인딩식별자와 값을 연결하는 과정을 바인딩이라 하고, 변수는 할당에 의해 값이 바인딩 된다. 일반함수 호출this는 전역객체(window)를 가리킨다. 내부함수 호출 this는 전역객체(window)를 가리킨다. method 호출 메소드를 호출한 객를 가리킨다. 생성자 함수 호출 생성자 함수가 생설할 미래의 인스턴스를 가르킨다. 콜백함수 호출 this는 전역객체(window)를 가리킨다. Function.prototype.apply/call/bind에 의한 간접 호출 API사용 연습문제 문자열 내 p와 y의 개수numPY함수는 대문자와 소문자가 섞여있는 문자열 s를 인수로 전달받는다.s에 존재하는 ‘p’의 개수와 ‘y’의 갯수를 비교해 같으면 true, 다르면 false를 리턴하도록 함수를 완성하라.대소문자를 구별하지 않으며 ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 true를 리턴한다. 예를 들어 s가 ‘pPoooyY’면 true를 리턴하고 ‘Pyy’라면 false를 리턴한다. 12345678910111213141516171819function numPY(s) { const str = s ? s.toLowerCase() : ''; let cntP = 0; let cntY = 0; for (let i = 0; i &lt;= str.length; i++) { if (str[i] === 'p') cntP++; if (str[i] === 'y') cntY++; } return cntP === cntY;}console.log(numPY('pPoooyY')); // trueconsole.log(numPY('Pyy')); // falseconsole.log(numPY('ab')); // trueconsole.log(numPY('')); // trueconsole.log(numPY()); // true 이상한 문자만들기toWeirdCase함수는 문자열을 인수로 전달받는다. 문자열 s에 각 단어의 짝수번째 인덱스 문자는 대문자로,홀수번째 인덱스 문자는 소문자로 바꾼 문자열을 리턴하도록 함수를 완성하라. 예를 들어 s가 ‘hello world’라면 첫번째 단어는 ‘HeLlO’, 두번째 단어는 ‘WoRlD’로 바꿔 ‘HeLlO WoRlD’를 리턴한다. 주의) 문자열 전체의 짝/홀수 인덱스가 아니라 단어(공백을 기준)별로 짝/홀수 인덱스를 판단한다. 123456789101112131415161718function toWeirdCase(str) { const strArr = str.split(' '); let result = ''; for (let i = 0; i &lt; strArr.length; i++) { for (let j = 0; j &lt; strArr[i].length; j++) { if (j % 2 === 0) result += strArr[i][j].toUpperCase(); else if (j % 2 === 1) result += strArr[i][j].toLowerCase(); } result += ' '; } return result;}console.log(toWeirdCase('hello world')); // 'HeLlO WoRlD'console.log(toWeirdCase('my name is lee')); // 'My NaMe Is LeE' 핸드폰번호 가리기핸드폰 요금 고지서에 표시할 전화번호는 개인정보 보호를 위해 맨 뒷자리 4자리를 제외한 나머지를 으로 바꿔야 한다.전화번호를 나타내는 문자열 str을 입력받는 hideNumbers 함수를 완성하라 예를들어 s가‘01033334444’면 **4444를 리턴하고, ‘027778888’인 경우는 *****8888을 리턴한다. 123456789101112131415function hideNumbers(s) { let result = ''; let star = ''; for (let i = 0; i &lt; s.length - 4; i++) { result += s[i]; star += '*'; } result = s.replace(result, star); return result;}console.log(hideNumbers('01033334444')); // *******4444console.log(hideNumbers('027778888')); // *****8888 문자열을 숫자로 바꾸기strToInt 메소드는 문자열을 인수로 전달받는다. 전달받은 문자열 인수를 숫자로 변환한 결과를 반환하도록 strToInt를 작성하라. 예를 들어 str이 ‘1234’이면 1234를 반환하고, ‘-1234’이면 -1234를 반환한다.str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없다. 123456789function strToInt(str) { // return +str; // return str * 1; // return Number(str); // return parseInt(str);}console.log(strToInt('1234')); // 1234console.log(strToInt('-1234')); // -1234 수박수박수박수박수박수?waterMelon 함수는 정수를 인수로 전달받는다. 길이가 n이고, 수박수박수…와 같은 패턴을 유지하는 문자열을 리턴하도록 함수를 완성하라. 예를 들어 n이 4이면 ‘수박수박’을 리턴하고 3이라면 ‘수박수’를 리턴한다. 12345678910111213function waterMelon(n) { const su = '수박'; let result = ''; for (let i = 0; i &lt; Math.ceil(n / 2); i++) { result += su; } return result.substring(0, n);}console.log('n이 3인 경우: '+ waterMelon(3));console.log('n이 4인 경우: '+ waterMelon(4)); 정수제곱근 판별하기nextSqaure함수는 정수를 인수로 전달받는다.n이 임의의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 임의의 정수 x의 제곱이 아니라면 ‘no’를 리턴하는 함수를 작성하라. 예를 들어 n이 121이라면 이는 정수 11의 제곱이므로 (11+1)의 제곱인 144를 리턴하고, 3이라면 ‘no’을 리턴한다. 123456789101112function nextSqaure(n) { return Number.isInteger(Math.sqrt(n)) ? (Math.sqrt(n) + 1) ** 2 : 'no';}console.log(nextSqaure()); // noconsole.log(nextSqaure(0)); // 1console.log(nextSqaure(1)); // 4console.log(nextSqaure(2)); // noconsole.log(nextSqaure(3)); // noconsole.log(nextSqaure(121)); // 144console.log(nextSqaure(165)); // noconsole.log(nextSqaure(400)); // 441 배열의 최대/최소값 구하기배열의 요소 중 최대값/최소값을 반환하는 함수를 완성하라. 12345678910111213function getMaxValueFromArray(array) { // return Math.max.apply(null, array); return Math.max(...array);}console.log(getMaxValueFromArray([3, 6, -2, -5, 7, 3])); // 7function getMinValueFromArray(array) { // return Math.min.apply(null, array); return Math.min(...array);}console.log(getMinValueFromArray([3, 6, -2, -5, 7, 3])); // -5","link":"/2019/05/17/til-20190517/"},{"title":"정리중","text":"정리중 1. DOM1.1. DOM tree1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .red { color: #ff0000; } .blue { color: #0000ff; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Cities&lt;/h1&gt; // h1 요소노드 안에 텍스트노드(자식관계)가 있음 &lt;ul&gt; &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; // li요소노드와 id어트리뷰트노드는 형제관계이다 &lt;li id=\"two\" class=\"red\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 돔트리 - Object가 최상단이다. 1.2. Dom Query / Traversing (요소에 접근)123document.querySelector('선택자') // 여러요소가 있을 경우 맨 앞에꺼 하나만 선택됨document.querySelectorAll('선택자') // 해당되는 모든 요소 선택 html 에서 요소의 id는 전역변수로 선언됨. 떄문에 가급적 class를 사용하는게 좋다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .red { color: #ff0000; } .blue { color: #0000ff; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Cities&lt;/h1&gt; &lt;ul&gt; &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; &lt;li id=\"two\" class=\"red\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; const elem = document.getElementById('one'); // 클래스 어트리뷰트의 값을 변경한다. elem.className += 'blue'; // 메서드를 사용한다. elem.classList.add('blue'); elem.classList.remove('blue'); // HTMLCollection(유사배열)을 반환한다. live(바뀌면 바로 바뀜)하다. const elems = document.getElementsByClassName('red'); for (let i = 0; i &lt; elems.length; i++) { // 클래스 어트리뷰트의 값을 변경한다. elems[i].className = 'blue'; } // blue, red, blue // 때문에 querySellector 를 사용한다. live가 아님 const elems = document.querySellectorAll('.red'); [...elems].forEach(elem =&gt; elem.className = 'blue'); const ul = document.querySellector('ul'); console.log(ul.firstElementChild); // id=\"one\" console.log(ul.firstElementChild.nextElementSibling); // id=\"two\" console.log(ul.listElementChild); // id=\"four\" &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.5. style1234567const four = document.getElementById('four');// inline 스타일 선언을 생성four.style.color = 'blue';// font-size와 같이 '-'으로 구분되는 프로퍼티는 카멜케이스로 변환하여 사용한다.four.style.fontSize = '2em'; 2. 동기식 처리 모델 VS 비동기식 처리 모델1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button class=\"btn\"&gt;Click me!!&lt;/button&gt; &lt;script&gt; const button = document.querySelector('.btn'); // button.onclick = function () { // 이벤트에 할일을 지정해줌 click됐을 때 이렇게 하라 // console.log('Clicked!!!'); // }; button.addEventListener('click', function () { // 인수를 3개 준다.(이벤트, 콜백함수, ) console.log('Clicked!!!'); }); console.dir(button); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3. Event3.2. 이벤트위임버블링을 사용한방법 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"post-list\"&gt; &lt;li id=\"post-1\" class=\"post-item\"&gt;Item 1&lt;/li&gt; &lt;li id=\"post-2\" class=\"post-item\"&gt;Item 2&lt;/li&gt; &lt;li id=\"post-3\" class=\"post-item\"&gt;Item 3&lt;/li&gt; &lt;li id=\"post-4\" class=\"post-item\"&gt;Item 4&lt;/li&gt; &lt;li id=\"post-5\" class=\"post-item\"&gt;Item 5&lt;/li&gt; &lt;li id=\"post-6\" class=\"post-item\"&gt;Item 6&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const ul = document.querySelector('.post-list'); // 버블링 사용 ul.addEventListener('click', function (e) { if (e.target.classList.contains('post-item')) console.log(e.target.id); }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2019/05/23/til-20190523/"},{"title":"러버덕, 복습, 예습","text":"아침 러버덕 값 더 이상 평가될 수 없는 표현식 문과 표현식 문은 표현식으로 이루어져 있다. 표현식인 문 변수에 할당할 수 있다. ex. 변수 선언문 표현식이 아닌 문 변수에 할당할 수 없다. ex. 할당문 리터럴 값을 만드는 방법 선언과 정의 선언 : 자바스크립트 엔진에 식별자를 알려 관리하도록 하는 것 정의 : 식별자의 정체를 알리는 것 호이스팅(변수, 함수) 변수의 선언이 자바스크립트의 런타임 이전에 실행되는 것 1. 웹브라우저HTTP 프로토콜을 이용해 서버와 브라우저가 Request(요청)와 Response(응답)을 주고 받는다. 서버가 Response를 주면 렌더링 엔진(HTML, CSS)과, 자바스크립트 엔진(JavaScript)에 의해 Parsing(텍스트로 된 파일을 컴퓨터가 알수있게 해석하는 것)된다. Parsing된 결과는 DOM(HTML이 해석된 결과), CSSOM(CSS가 해석된 결과), Sysntax Tree(JavaScript가 해석된 결과)트리로 변환 되고 DOM과 CSSOM 트리가 완성되면 Sysntax Tree가 앞에 두개에 영향을 끼쳐 Render Tree(다 합쳐진결과)로 결합된다. 2. 변수 2.1. 할당과 참조예제) 숫자 값 10과 20을 + 연산자로 합산하고 있다. 110 + 20 숫자 값 10과 20은 메모리 상의 임의의 위치(주소, address)에 저장되고, 연산 결과로 생성된 숫자 값 30도 메모리 상의 임의의 위치에 저장되지만 숫자 값 30은 재사용할 수 없다. 값의 재사용을 위해 변수(하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다)를 사용한다. 예제) 숫자 값 10과 20을 + 연산자로 합산하고, 변수 result 에 저장한다. 1var result = 10 + 20; 숫자 값 10과 20을 합산한 결과를 변수 result에 저장하는 것을 할당이라 하고, 변수에 저장 된 값을 읽어 들이는 것을 참조라고 한다. 변수명은 식별자로도 부른다. 식별자가 상위의 개념이고 변수, 함수, 클래스 등의 이름과 같은 식별자는 모두 선언에 의해 자바 스크립트 엔진에 식별자의 존재를 알린다. 2.2. 변수 선언변수 선언이란 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다. 변수를 사용하려면 반드시 선언이 필요하다. 선언시 var, let, const 키워드를 사용한다. 1var score; // 변수의 선언(변수 선언문) 키워드 var를 이용해 score라는 변수를 선언했다. 아직 값을 할당하지 않았지만 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 있다. 2.3. 변수 선언의 실행 시점과 변수 호이스팅12console.log(score); // undefinedvar score; 자바스크립트는 한줄씩 순차적으로 실행되므로 변수의 선언보다 참조가 앞에 있으면 에러를 발생할 것처럼 보인다. 하지만 에러는 발생하지 않는다. 위에 출력은 undefined로 나타난다. 자바스크립트는 변수 선언을 우선적으로 처리하기 때문이다. 런타임(소스코드가 순차적으로 실행되는 시점)이 아닌 이전의 파싱타임에 먼저 시행시켜 호이스팅이라는 작업을 하기 때문이다. 모든 선언문은 런타임이 아닌 파싱 타임에 먼저 실행된다. 2.4. 값의 할당1234var score; // 변수 선언score = 30; // 값의 할당var score = 30; // 변수 선언과 값의 할당 변수에 값을 할당할 때는 할당 연산자(=)를 기준으로 우변의 값을 좌변에 할당한다. 변수 score를 선언한 시점에는 undefined로 초기화되어 있다. score=30으로 값을 할당하는 행위는 엄밀히 따지면 30으로 값을 재할당했다고 한다. const 키워드 const는 상수를 표현하는 키워드로 값의 재할당이 금지된다. 2.5. 식별자 네이밍 규칙1234567891011// 카멜 케이스var firstName;// 스네이크 케이스var first_name;// 파스칼 케이스var FirstName;// 헝가리언 케이스var strFirstName; // type + identifier 3. 데이터 타입모든 값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 할당하고 참조하기 위해서는 확보해야할 메모리 공간의 크기와 읽어와야할 메모리 공간의 크기를 알아야한다. 1var score = 100; // type Number = 8byte; 위 예제에서 자바스크립트 엔진은 값 100을 숫자 타입으로 인식하고 선두 메모리 셀을 기준으로 8byte의 메모리 공간을 확보한다. 1score 참조를 위해서는 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 필요가 있다. 이때 컴퓨터는 한번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(byte 수)를 알아야 한다. 변수 score에는 숫자 타입의 값이 할당되어 있으므로 선두 메모리 셀을 기준으로 셀 8개를 읽어온다. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 4. 연산자 4.1. 표현식과 연산자표현식은 하나의 값으로 평가될 수 있는 문이다. 표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식 등이 있지만 결국 평가되어 하나의 값이 된다. 4.2. 문과 표현식문은 하나 이상의 표현식과 키워드의 조합으로 구성되어 자바스크립트 엔진에게 내리는 명령이다. 자바스크립트의 모든 코드는 문 또는 표현식이다. 표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것이다. 4.3. 표현식인 문과 표현식이 아닌 문표현식인 문과 아닌 문을 구별하기 위한 가장 간단한 방법은 병수에 할당해 보는 것이다. 표현식인 문은 변수에 할당할 수 있고, 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당할 수 없어서 에러가 발생한다. 1234567// 변수 선언문은 표현식이 아닌 문이다.var x;// 따라서 변수 선언문은 표현식이 아닌 문이다.var x = var y; // SyntaxError// 할당문 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.x = 100; 4.4. 연산자란?하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산등을 수행해 하나의 값을 만든다. 연산의 대상을 피연산자라 부른다. 4.5. 산술 연산자산술연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다. 산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다. 4.5.1. 이항 산술 연산자이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 피연산자의 값이 바뀌지 않고 언제나 새로운 값을 만든다. + : 덧셈 - : 뺄셈 * : 곱셈 / : 나눗셈 % : 나머지 4.5.2. 단항 산술 연산자단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 증가/감소(++ / –) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. 다시 말해 증가/감소 연산을 하면 피연산자의 값이 바뀐다. ++ : 증가 -- : 감소 + : 어떠한 효과도 없다. - : 양수를 음수로 음수를 양수로 반전한 값을 반환한다. 4.5. 할당 연산자할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다. 12345678910111213// = += -= *= /= %=x = 10; // 10x += 5; // x = x + 5 15x -= 5; // x = x - 5 10x *= 5; // x = x * 5 50x /= 5; // x = x / 5 10x %= 5; // x = x % 5 0 4.6. 비교 연산자비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다. == : 동등 비교 ( x == y, x와 y의 값이 같음) === : 일치 비교 (x === y, x와 y의 값과 타입이 같음) != : 부동등 비교 (x != y, x와 y의 값이 다름) !== : 불일치 비교 (x !== y, x와 y의 값과 타입이 다름) 123456789101112// 동등 비교5 == 5 // true// 타입은 다르지만 암묵적 타입 변환을 한다.5 == '5' // ture// 일치 비교5 === 5 // true// 암묵적 타입 변환을 하지 않고 값을 비교한다.// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.5 === '5' // false 4. 7. 대소 관계 비교 연산자대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다. &gt; : x &gt; y, x가 y보다 크다. &lt; : x &lt; y, x가 y보다 작다. &gt;= : x &gt;= y, x가 y보다 크거다 같다. &lt;= : x &lt;= y, x가 y보다 크거다 작다. 12345 &gt; 0 // true5 &gt; 5 // false5 &gt;= 5 // true5 &lt;= 5 // true 4.8. 삼항 조건 연산자삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 1조건식 ? 조건식이 true 일 때 반환할 값 : 조건식이 false일 때 반환할 값 12345678910111213141516171819var x = 2;// 2 % 2 는 0이고 0은 false로 암묵적 타입 변환이 된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수// if...else문으로 동일한 처리var x = 2;var result;if(x % 2){ result = '홀수';} else{ result = '짝수';}console.log(result); // 짝수 삼항 조건 연산자와 if…else문은 동일하게 사용할수 있지만 if…else문은 표현식이 아닌문이다. 따라서 if…else 문은 값처럼 사용할 수 없다. 4.9. 논리 연산자논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다. || : 논리합(OR) &amp;&amp; : 논리곱(AND) ! : 부정(NOT) 123456789101112131415// 논리합(||) 연산자console.log(true || true); // trueconsole.log(true || false); // trueconsole.log(false || true); // trueconsole.log(false || false); // false// 논리곱(&amp;&amp;) 연산자console.log(true &amp;&amp; true); // trueconsole.log(true &amp;&amp; false); // falseconsole.log(false &amp;&amp; true); // falseconsole.log(false &amp;&amp; false); // false// 논리 부정(!) 연산자console.log(!true); // falseconsole.log(!false); // true","link":"/2019/05/06/til-20190506/"},{"title":"러버덕, 원시 값, 객체, 함수, 스코프","text":"아침 러버덕 명시적 / 암묵적 타입변환 명시적 타입변환 : 개발자가 의도적으로 타입을 변환하는 것. 암묵적 타입변환 : 자바스크립트 엔진에 의해 타입이 변환되는 것. 내 생각 : 메서드의 사용여부가 명시적 / 암묵적을 나누는 것 같음. 단축평가(&amp;&amp;, ||) &amp;&amp;(and, 논리 곱) : 두개의 피연산자가 모두 true일 경우 true를 반환한다. ||(or, 논리 합) : 두개의 피연산자 중 하나만 true이면, true를 반환한다. 12345678'cat' &amp;&amp; 'dog' // 'dog'false &amp;&amp; 'cat' // false'dog' &amp;&amp; false // false'' &amp;&amp; false // 좌항을 반환한다.'cat' || 'dog' // 좌항을 반환한다.false || 'dog' // 'dog'false || false // 좌항을 반환한다. 자바스크립트에서의 객체란 무엇인가? 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이고, 변경 가능한 값(mutable value)이다. 자바스크립트 객체 프로퍼티 여러 접근 방법 마침표 표기법과 대괄호 표기법이있다. 123person.name;person['name']; 1. 원시 값원시 타입의 값은 변경 불가능한 값(immutable value)이다. 여기서 변경 불가능한 값은 상수와는 다른 개념이다. 원시 값의 장점은 재할당 이외에는 절대 값이 바뀌지 않아, 비교적 오류를 범하지 않을 수 있다. 변수 : 재할당이 가능하다. 상수 : 재할당이 불가능하다. 123// 원시 값var score; // 변수를 선언하고 undefined를 할당한다.score = 30; // undefined가 들어있는 메모리 공간과는 별개로 새로운 공간에 30을 생성하고 할당한다. 1.1. 값에 의한 전달위에서 할당한 변수는 원시 타입이다. 변수 foo와 bar는 전혀 다른 메모리에 별개로 저장되어 할당한 변수값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 12345var foo = 10;var bar = foo;foo = 100;console.log(bar); // 10 2. 객체객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다. 객체는 복합적인 자료 구조이므로 객체를 관리하는 방식이 원시 값과 비교하여 매우 복잡하고 비용이 많이 든다. 때문에, 객체가 뮤터블인이유이다 객체는 순서 개념이 없다. key 즉, name으로 값을 찾는다. 2.1. 변경 가능한 값원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만, 객체를 할당한 변수는 참조 값(Reference value)을 값으로 갖는다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다. 1234567891011var person = { name: 'lee'};// 프로퍼티 값 갱신person.name = 'kim';// 프로퍼티 동적 추가person.address = 'seoul';console.log(person); // {name: 'kim', address: 'seoul'} 2.2. 참조에 의한 전달person의 참조값을 copy에 복사해서 전달한다. 이를 참조에 의한 전달(Pass by reference)이라 한다. 같은 메모리 주소 값을 변수 값으로 가지고 있어서 같은 메모리 공간을 참조하고 있다. 123456var person = { name: 'lee'};// 참조 값을 복사var copy = person; 얕은 복사(shallow copy)와 깊은 복사(deep copy) 참조 값을 복사하는 것을 얕은 복사(shallow copy), 원시 값처럼 객체 자체를 복사하여 다시 생성하는 것을 깊은 복사(deep copy)라 한다. 3. 함수함수는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다. 여기서 함수는 객체이기도 하다. 함수는 정의만으로 실행되지 않는다. 인수를 매개변수를 통해 함수에게 전달한다. 이를 함수 호출이라한다. 1234567// 함수 정의function add(x, y){ // add : 함수명 x, y : 매개변수 return x + y; // {} : 함수 몸체}// 함수 호출add(1, 3); // 인수 3.1. 함수의 사용 이유함수를 사용하는 이유는 코드의 재사용에 있다. 재사용이 주는 이점은 유지보수의 편의성을 높여 실수를 줄이고 코드의 신뢰성을 높인다. 3.3. 함수 선언문변수 선언문을 사용하지 않은 함수 리터럴이고, 함수명을 생략할 수 없다. 함수 선언문은 선언과 초기화가 한 번에 해결된다.(함수 호이스팅) 12345678910// 함수 선언문function add(x, y){ return x + y;};// 자바스크립트 엔진이 런타임 이전에 함수명과 동일한 변수를 선언하고 할당한다.var add = function add(x, y) { return x + y;}; 3.4. 함수 표현식함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 함수 표현식은 일반적으로 함수명을 생략한다. 함수 표현식은 변수선언이 이루어 지고 런타임에 객체가 할당된다.(변수 호이스팅) 1234// 함수 표현식, 런타임 이전에 변수 선언을 한다.var add = function(x, y){ return x + y;}; 3.5. 함수 호출함수는 함수를 참조하는 인수(argument)와 함수 호출 연산자인 매개변수(parameter)로 구성되어 있다. 3.6. 즉시 실행 함수함수의 정의와 동시에 즉시 호출되고 한 번만 호출되며 다시 호출할 수 없다. 즉시 실행 함수는 함수명이 없는 익명 즉시 실행 함수를 사용하는 것이 일반적이다. 즉시 실행 함수의 사용 목적은 즉시 실행 함수 내에 코드를 모아 두면 변수명, 함수명의 충돌을 방지하기 떄문이다. 12345(function(){ var a = 3; var b = 5; return a * b;}()) 3.7. 중첩 함수함수 내부에 정의된 함수를 중첩함수 또는 내부함수라 한다. 일반적으로 중첩 함수는 외부함수를 돕는 헬퍼 함수역할을 한다. 123456789101112function outer(){ var x = 1; function inner(){ var y = 2; // 중첩함수는 외부함수의 변수를 참조할 수 있다. console.log(x + y); // 3 } // 외부함수는 중첩함수의 변수를 참조할 수 없다. console.log(x + y); // y를 참조할 수 없다.} // 이와 같은 개념을 스코프라 한다. 3.8. 콜백 함수자바스크립트의 함수는 일급 객체이므로 함수의 인수로 함수를 전달할 수 있다. 아래 예제는 강사님의 예제이다. 123456789101112131415161718// 콜백 함수를 전달받는 함수function print(f){ var string = 'Hello'; return f(string);}// print 함수에 콜백 함수를 전달하면서 호출var res1 = print(function(str){ return str.toUpperCase();});// print 함수에 콜백 함수를 전달하면서 호출var res2 = print(function(str){ return str.toLowerCase();});console.log(res1, res2); // HELLO hello 이해가 되지않아 나만의 그림으로 그려봤다. 절대 이런 방식으로 콜백이 일어나지 않지만, 이런식으로 이해 해봤다. 제이쿼리를 쓸 때 콜백인지 뭔지도 모르고 썼던 클릭이벤트 사용이 예제로 나왔다. 1234// myButton 버튼을 클릭하면 콜백함수를 실행해 콘솔로그로 'button clicked!'가 나온다.document.getElementById('myButton').addEventListener('click', function () { console.log('button clicked!');}); 4. 스코프변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위를 결정한다. 이 범위를 스코프라 한다. 12345678910var x = 'global'; // 전역변수(스코프)function foo() { var x = 'local'; // foo함수 내에서의 지역변수(스코프) console.log(x); // local}foo();console.log(x); // global 4.1. 스코프 체인스코프는 함수의 중첩에 의해 계층적 구조를 갖는다. 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다. 이때 외부 함수의 지역 스코프를 중첩함수의 상위 스코프라 한다. 모든 스코프는 하나의 계층적 구조로 연결되며 모든 지역 스코프의 최상위 스코프를 전역 스코프라 한다. 이렇게 스코프가 계층적으로 연결된 것을 스코프 체인이라 부른다. 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동하며 변수를 검색한다. 밑에 예제를 보면 이해하는데 많은 도움이 되는 것 같다. 123456789101112131415161718192021222324var x = 10;var y = 20;var z = 40;function foo(){ var z = 30; console.log(x); // 10 console.log(y); // 20 console.log(z); // 30 function bar(){ var x = 50; console.log(x); // 50 console.log(y); // 20 console.log(z); // 30 } bar();}foo();console.log(x); // 10console.log(y); // 20console.log(z); // 40 4.2. 함수 레벨 스코프함수 레벨 스코프는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다. var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프라 한다. 123456789101112131415// var 키워드는 블록 레벨 스코프를 인정하지 않는다.var x = 1;if(ture){ var x = 10;}console.log(x); // 10// var 키워드는 함수 레벨 스코프를 인정한다.function(){ var x = 300;}console.log(x); // 10 4.3. 렉시컬 스코프자바스크립트의 렉시컬 스코프는 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. 12345678910111213var x = 1;function foo() { var x = 10; bar();}function bar() { console.log(x);}foo(); // 1bar(); // 1 4.4. 암묵적 전역 변수선언하지 않은 변수에 값을 할당하면 자바스크립트 엔진은 아무런 에러없이 암묵적으로 전역 변수를 선언하고 값을 할당한다. 1234567function foo(){ x = 10;}foo();console.log(x); // 10","link":"/2019/05/08/til-20190508/"},{"title":"러버덕, 생성자 함수, 프로토타입","text":"아침 러버덕 var 키워드로 선언한 변수의 문제점 같은 스코프 내에서 중복 선언이 허용된다. 블록 레벨 스코프를 지원하지 않는다.(함수 레벨 스코프) 변수 호이스팅 전역 변수의 문제점 암묵적 결함 모든 코드가 전역 변수를 참조하고 변경할 수 있다.코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다. 긴 생명 주기 전역 변수의 상태를 변경할 수 있는 시간이 길다. 메모리 리소스를 오랜 기간 소비한다. 스코프 체인 상에서 종점에 존재 변수를 검색할 때 전역 변수가 가장 마지막에 검색 된다.즉, 전역 변수의 검색 속도가 가장 느리다. 네임 스페이스 오염 파일이 분리되어 있다하여도 하나의 전역 스코프를 공유한다.다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다. 1. 생성자 함수(Constructor) 1.1. 객체 리터럴에 의한 객체 생성 방식의 문제점객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다. 하지만 객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만을 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다. 1234567891011121314151617const circle1 = { radius: 5, getDiameter() { return 2 * this.radius; }};console.log(circle1.getDiameter()); // 10const circle2 = { radius: 10, getDiameter() { return 2 * this.radius; }};console.log(circle2.getDiameter()); // 20 1.2. 생성자 함수에 의한 객체 생성 방식의 장점생성자 함수에 의한 객체 생성 방식은 마치 객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 123456789101112131415// 생성자 함수function Circle(radius) { // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// 인스턴스의 생성const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20 thisthis는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이다. this가 가리키는 객체는 함수 호출 방식에 따라 동적으로 결정된다. 빌트인(네이티브), 생성자 함수(레퍼 객체) 생성자 함수 내부에서는 리턴을 쓰지 않는다. 1234567891011121314151617function Person(name){ // this는 생성자 함수가 미래에 생설할 객체 // 1. 빈객체(인스턴스) 생성하고 this에 바인딩 this.name = name; this.sayHello = function () { console.log(`hello ${this.name}!`); } // 2. this를 암묵적 반환}// Person(); // undefined// new Person(); // Person {}const me = new Person('Lee');console.log(me); // Person {name: 'Lee', sayHello: [Function]}me.sayHello(); // 'hello Lee!'const you = new Person('Kim');you.sayHello(); 바인딩과 할당 변수는 ‘할당한다’ 말하고, 식별자는 ‘바인딩한다’ 말한다. 2. constructor와 non-constructor의 구분화살표함수와 es6 메소드 축약표현은 생성자 함수로 호출할 수 없다. 3. 함수 객체의 프로퍼티 3.1. arguments가변 인자 함수를 구현할 때 유용하게 사용된다. 1234567891011121314function sum() { let res = 0; // arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다. for (let i = 0; i &lt; arguments.length; i++) { res += arguments[i]; } return res;}console.log(sum()); // 0console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3)); // 6 3.2. __proto__ 접근자 프로퍼티모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다. 데이터 프로퍼티 : 객체가 가지고 있는 프로퍼티 중에 value 가 있다. (함수 객체만 가지고 있다.) 접근자 프로퍼티 : value가 없다. (모든객체가 가지고 있다.) 12345678910111213141516171819const obj = { a: 1 };// 첫번째 인자로 된객체에 프로퍼티 이름을 주면 프로퍼티의 어트리뷰트를 반환한다.console.log(Object.getOwnPropertyDescriptor(obj, 'a')); // {value: 1, writable: true, enumerable: false, configurable: false}// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.console.log(obj.__proto__ === Object.prototype); // true// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.// hasOwnProperty 메소드는 Object.prototype의 메소드이다.console.log(obj.hasOwnProperty('a')); // trueconsole.log(obj.hasOwnProperty('__proto__')); // falseconsole.log(obj.getOwnPropertyDescriptor(obj, '__proto__')); // undefinedconsole.log(Object.getOwnPropertyDescriptor(Object.prototype,'__proto__')); // 접근자 프로퍼티// {get: ƒ, set: ƒ, enumerable: false, configurable: true} 4. 프로토타입자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 4.1. 객체지향 프로그래밍객체지향 프로그래밍(Object Oriented Programming, OOP)은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍(Imperative Programming)의 절차지향적 관점에서 벗어나 프로그램을 여러개의 독립적 단위, 즉 객체들의 집합으로 표현하려는 프로그래밍 패러다임을 말한다. 이해를 위해 객체는 사람, 속성(property)을 사람의 특징이라 하면 아래와 같다. 1234const person = { name: 'ChoiSungJin', age: 25}; 이처럼 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려 내어 표현하는 것을 추상화라한다. 이 속성들 중 이름을 소개한다는 동작이 있다고 생각해보자. 123456789const person = { name: 'ChoiSungJin', age: 25, sayHi() { return `안녕 내 이름은 ${this.name}이야.`; }};console.log(person.sayHi();) // '안녕 내 이름은 ChoiSungJin이야.' 여기서의 동작을 메서드라 하고, 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조를 객체(object)라 한다. 객체의 상태 데이터를 프로퍼티(property), 동작을 메소드(method)라 부른다. 4.2. 상속과 프로토타입상속은 객체지향 프로그래밍의 핵심 개념으로 상위 객체의 프로퍼티 또는 메소드를 하위 객체가 상속받아 그대로 사용할 수 있는 것을 말한다. 12345678910111213141516function Person(name) { this.name = name; this.sayHi = function () { return `안녕 내 이름은 ${this.name}이야.` }}// 이름이 최성진인 인스턴스 생성const me = new Person('최성진');// 이름이 이규하인 인스턴스 생성const you = new Person('이규하');console.log(me.sayHi === you.sayHi); // falseconsole.log(me.sayHi()); // '안녕 내 이름은 최성진이야.'console.log(you.sayHi()); // '안녕 내 이름은 이규하이야.' 여기서 sayHi 메소드는 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직한데, Person 생성자 함수는 인스턴스를 생성할 때마다 sayHi 메소드를 중복 생성하여 모든 인스턴스가 중복 소유하고 있다. 이러한 중복을 상속, 즉 프로토타입을 기반으로 구현하면 아래와 같다. 123456789101112131415161718function Person(name) { this.name = name;}// sayHi 메소드를 Person 생성자 함수의 프로토타입에 추가한다.Person.prototype.sayHi = function () { return `안녕 내 이름은 ${this.name}이야.`;}// 이름이 최성진인 인스턴스 생성const me = new Person('최성진');// 이름이 이규하인 인스턴스 생성const you = new Person('이규하');console.log(me.sayHi === you.sayHi); // trueconsole.log(me.sayHi()); // '안녕 내 이름은 최성진이야.'console.log(you.sayHi()); // '안녕 내 이름은 이규하이야.' 모든 함수는 prototype 객체를 가지고 태어난다. Person 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 객체 역할을 하는 Person.prototype의 모든 프로퍼티와 메소드를 상속받는다. 상속은 코드의 재사용이란 관점에서 매우 유용하다.","link":"/2019/05/13/til-20190513/"},{"title":"정리중","text":"정리중 러버덕 고차함수란 무엇이고 어떻게 활용되는지? 인수로 함수를 받거나 리턴값이 함수이거나 혹은 둘다 함수형 프로그래밍을 지향하기 위해 사용한다. (변수 사용억제, 가독성) Rest parameter, spread operator 가 무엇이고 어떻게 활용하는지 12345678910111213141516171819202122232425262728// Rest parameter는 반드시 마지막 파라미터여야 한다.// 인수의 리스트를 함수 내부에서 배열로 전달받을 수 있다.function foo(a, ...rest) { console.log(Array.isArray(rest)); // true console.log(rest); // [1, 2, 3, 4, 5]}foo(1, 2, 3, 4, 5);// Spread operator 피연산자를 개별 요소로 분리한다. Spread 연산자의 피연산자는 이터러블이어야 한다. function foo(x, y, z) { console.log(x); // 1 console.log(y); // 2 console.log(z); // 3 }// 배열을 foo 함수의 인자로 전달하려고 한다.const arr = [1, 2, 3]; // ...[1, 2, 3]는 [1, 2, 3]을 개별 요소로 분리한다(→ 1, 2, 3)// spread 연산자에 의해 분리된 배열의 요소는 개별적인 인자로서 각각의 매개변수에 전달된다.foo(...arr); // 1 2 3 // 이터러블 -&gt; Array, String, Map, Set, TypedArray(Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array), DOM data structure(NodeList, HTMLCollection), Arguments console.log(...'hello'); // h e l l o 1. 클래스1.7. 정적메소드12345678910111213141516171819202122class Foo { constructor(prop) { this.prop = prop; } static staticMethod() { // Foo.staticMethod() // 정적 메소드는 this를 사용할 수 없다. // 정적 메소드 내부에서 this는 클래스의 인스턴스가 아닌 클래스 자신을 가리킨다. return 'staticMethod'; } prototypeMethod() { // foo.prototypeMehod() return this.prop; }}// 정적 메소드는 클래스 이름으로 호출한다.console.log(Foo.staticMethod());const foo = new Foo(123);// 정적 메소드는 인스턴스로 호출할 수 없다.console.log(foo.staticMethod()); // Uncaught TypeError: foo.staticMethod is not a function 3. 묘듈","link":"/2019/05/22/til-20190522/"},{"title":"러버덕, TodoList, MVC","text":"아침 러버덕 동기식 처리와 비동기식 처리 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051setTimeout(() =&gt; { console.log('A');}, 3000);setTimeout(() =&gt; { console.log('B');}, 3000);setTimeout(() =&gt; { console.log('C');}, 3000);/*뒙api로 들어가서 3초 타이머 실행 그런데 모든 함수가 다들어간다.3초가 끝나면 이벤트큐(콜백큐)로 들어가서 콜스택이 비어있는지 이벤트루프가 확인하고 비어있다면 이벤트 루프를 통해서 콜스택으로 전달하고 콜스택이 출력한다.비동기식, 3초후 A B C 순으로 바로 출력된다.ABC*/setTimeout(() =&gt; { console.log('A'); setTimeout(() =&gt; { console.log('B'); setTimeout(() =&gt; { console.log('C'); }, 3000); }, 3000);}, 3000);/*첫번째 셋타임아웃이 웹api로 들어가서 3초타이머 후 이벤트큐로 갔다가 콜스택으로 간다음 출력 되고 두번째 함수들이 실행된다.3초후 A6초후 B9초후 C*/setTimeout(() =&gt; { console.log('A');}, 3000);setTimeout(() =&gt; { console.log('C');}, 0);console.log('B');/*첫번째 셋타임아웃이 실행되면 웹api로 들어가서 3초를 기다리고 다음에 웹api로 두번째 셋타임아웃도 들어가고 다음에 콘솔로그는 바로 콜스택으로 들어가서 출력되고0초가 지나니까 이벤트큐로 들어가서 콜스택 출력 다음 3초가 지나고 이벤트큐 다음 콜스택 출력*/ 1. TodoList 만들기 1.1. 어트리뷰트와 프로퍼티어트리뷰트는 요소가 가지고 있는 초기값이고, 프로퍼티는 변화하는 성질을 가지고 있어서 최신상태를 확인할 수 있다. 1.2. MVC(model - view - controller)웹 애플리캐이션의 삼단구조, 즉 사용자가 조작하면 데이터를 가져오고 그 정보를 시각적으로 표현하는 구조를 말한다. model 데이터베이스가 변화할 경우 controller와 view에 이를 통보한다.(라우팅) view 사용자가 시각적으로 볼 결과물을model로 부터 정보를 얻어 온다. controller model에 명령을 보내 model의 상태를 변경할 수 있다. 1.3. html1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 1.0&lt;/title&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"javascript/app.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;1.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"todos\"&gt; &lt;!-- &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"custom-checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;div class=\"footer\"&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"custom-checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1.3. javascript$ 표시가 붙은 변수는 Dom요소를 조작한다는 통상적인 약속이다. html의 상태를 로드없이 변경하기 위해 html 변수에 문자열로 html 문서를 작성해서 저장하고 javascript의 객체를 직접 컨트롤해 render() 함수를 실행했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081let todos = [ { id: 1, content: 'HTML', completed: true }, { id: 2, content: 'CSS', completed: true }, { id: 3, content: 'Javascript', completed: false }];const $inputTodo = document.querySelector('.input-todo');const $todos = document.querySelector('.todos');const $checkAll = document.querySelector('#ck-complete-all');const $completedTodos = document.querySelector('.completed-todos');const $btn = document.querySelector('.btn');const $activeTodos = document.querySelector('.active-todos');render();function render() { let html = ''; todos.forEach(todo =&gt; html += `&lt;li id=\"${todo.id}\" class=\"todo-item\"&gt; &lt;input id=\"ck-${todo.id}\" class=\"custom-checkbox\" type=\"checkbox\" ${todo.completed ? 'checked' : ''}&gt; &lt;label for=\"ck-${todo.id}\"&gt;${todo.content}&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt;\\n`); $todos.innerHTML = html; completedTodos(); activeTodos();}function generateId() { return todos.length ? Math.max(...todos.map(todo =&gt; todo.id)) + 1 : 1;}function completedTodos() { $completedTodos.innerHTML = todos.filter(function (todo) { return todo.completed; }).length;}function activeTodos() { $activeTodos.innerHTML = todos.filter(function (todo) { return !todo.completed; }).length;}$todos.addEventListener('click', function (e) { if (!e.target.classList.contains('remove-todo')) return; todos = todos.filter(todo =&gt; todo.id !== +e.target.parentNode.id); render();});$todos.addEventListener('change', function (e) { const id = +e.target.parentNode.id; todos = todos.map(todo =&gt; (todo.id === id ? Object.assign({}, todo, { completed: !todo.completed }) : todo)); completedTodos(); activeTodos();});$inputTodo.addEventListener('keyup', function (e) { const value = $inputTodo.value.trim(); if (value === '' || e.keyCode !== 13) return; todos = [...todos, { id: generateId(), content: value, completed: false }]; $inputTodo.value = ''; render();});$checkAll.addEventListener('change', function () { todos = todos.map(todo =&gt; (this.checked ? Object.assign({}, todo, { completed: true }) : Object.assign({}, todo, { completed: false }))); render();});$btn.addEventListener('click', function () { todos = todos.filter(todo =&gt; !todo.completed); render();});","link":"/2019/05/27/til-20190527/"},{"title":"정리중","text":"1. 프로미스정리중 1. 프로미스기존 ajax의 문제점인 에러를 잡지 못하고, 콜백헬이발생한다는 것을 잡았따.","link":"/2019/05/31/til-20190531/"},{"title":"Ajax","text":"1. Ajax데스크탑 어플리케이션과 유사한 ux를 구사할 수 있다. 깜빡거리지 않는다.(리로드되지 않는다.) 1.1. server Web Server HTML, CSS, JavaScript, jpg, wvg 등등 정적인 파일(static, 원래 있는 파일을 가져오는 것) Application Server(Web Server의 하위개념?) REST API를 처리할 수 있다. 우리가 보통 사용하는 서버 Database Server 1.2. JSON(JavaScript Object Notation)클라이언트와 서버간의 데이터 교환을 위한 텍스트 데이터 구조(포맷)이다. 1234567// key와 value를 반드시 쌍따옴표로 처리한다(Number, bleelan 빼고).{ \"name\": \"Lee\", \"gender\": \"male\", \"age\": 20, \"alive\": true} 1.3. JSON.stringify객체상태, 배열상태의 데이터를 서버로 보낼때 사용한다. 12345678910111213const o = { name: 'Lee', gender: 'male', age: 20 };// 객체 =&gt; JSON 형식의 문자열const strObject = JSON.stringify(o);console.log(typeof strObject, strObject);// string {\"name\":\"Lee\",\"gender\":\"male\",\"age\":20}const arr = [1, 5, 'false'];// 배열 객체 =&gt; 문자열const strArray = JSON.stringify(arr);console.log(typeof strArray, strArray); // string [1,5,\"false\"] 1.4. JSON.parse서버에서 받아온 문자를 객체로 바꿔준다. 1234567// JSON 형식의 문자열 =&gt; 객체const obj = JSON.parse(strObject);console.log(typeof obj, obj); // object { name: 'Lee', gender: 'male' }// 문자열 =&gt; 배열 객체const objArray = JSON.parse(strArray);console.log(typeof objArray, objArray); // object [1, 5, \"false\"] 2. XMLHttpRequest브라우저는 XMLHttpRequest 객체를 이용하여 Ajax 요청을 생성하고 전송한다. 서버가 브라우저의 요청에 대해 응답을 반환하면 같은 XMLHttpRequest 객체가 그 결과를 처리한다. 2.1. Ajax request123456789// XMLHttpRequest 객체의 생성const xhr = new XMLHttpRequest();// 비동기 방식으로 Request를 오픈한다(준비동작)// html form태그와 동일하게 메서드와, 액션을 작성한다.xhr.open('GET', '/users');// Request를 전송한다xhr.send(); 2.2. XMLHttpRequest.open1XMLHttpRequest.open(method, url[, async]) 메서드 get(조회) 싹다 가져올거냐, 특정것만 가져올거냐. url뒤에 키와밸류값으로 uri형식으로 보낸다(보안에 취약하다), 1// https://www.naver.com/login.php?userid=\"abc\"&amp;password=\"123\" post(생성) 생성할때 사용한다. 데이터를 숨겨서 보낸다. delete 서버가 가지고 있는 데이터를 지운다. 하나를 지워라(인수O 일반적으로 id를 줌), 싹 다 지워라(인수X). put 요소 전체를 싹 다 갱신하라.(payload로 아이디를 줘야함) patch 요소의 하나만 갱신하라(일반적으로 id를 줌) 2.3. XMLHttpRequest.send12345xhr.send(null); // get방식이다 페이로드가 없다.xhr.send('string'); // post방식이다. 페이로드가 있다.xhr.send(new Blob()); // 파일 업로드와 같이 바이너리 컨텐트를 보내는 방법xhr.send({ form: 'data' }); // json형식xhr.send(document); // 객체로 넘길 수 있다. 3. REST APIjson파일의 패이로드를 주고 받을 키와 밸류를 규약하는 방법론 3.1. CRUD (create, read, update, delete)post, get, put path, delete 3.2. Mock(짝퉁서버)","link":"/2019/05/29/til-20190529/"},{"title":"모듈","text":"모듈모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다. 모듈은 캡슐화하고 공개가 필요한 API만을 외부에 노출한다. 모듈은 애플리케이션에 분리되어 개별적으로 존재하다가 애플리케이션의 로드에 의해 비로소 애플리케이션의 일원이 된다. 모듈은 기능별로 분리되어 작성되므로 코드의 단위를 명확히 분리하여 애플리케이션을 구성할 수 있으며 재사용성이 좋아서 개발 효율성과 유지보수성을 높일 수 있다. 하지만 이러한 모듈 기능을 자바스크립트는 제공하지 않는다. 이러한 자바스크립트의 문제를 해결하기 위해 제안된 것이 CommonJS와 AMD(Asynchronous Module Definition)이다. 자바스크립트의 모듈화는 크게 CommonJS 진영과 AMD 진영으로 나뉘게 되었고 브라우저에서 모듈을 사용하기 위해서는 모듈 로더 라이브러리를 사용해야 하는 상황이 되었다. 이러한 상황에서 ES6에서는 모듈기능을 추가하였다. 12&lt;script type=\"module\" src\"app.js\"&gt;&lt;/script&gt;&lt;script type=\"module\" src\"subapp.js\"&gt;&lt;/script&gt; 아쉽게도 이러한 기능들은 몇가지 이유로 상용화되지 못하고 실상은 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다. 1. 파일 스코프모듈화를 한다는 것은 결국 각각의 파일 스코프를 만든다는 말과 같다. 1234// foo.jsvar x = 'foo';console.log(x); 1234// bar.jsvar x = 'bar';console.log(x); 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script src=\"foo.js\"&gt;&lt;/script&gt; &lt;script src=\"bar.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 위와 같이 자바스크립트 파일을 독립된 두개의 파일로 나누어 로드하여도 결국 하나의 전역을 공유한다. 그렇게 되면 foo.js에서 선언된 x는 bar.js에서 선언된 x가 엎어 써진다. 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt; &lt;script type=\"module\" src=\"bar.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 하지만 위와 같이 module 타입을 명시해주면 각각의 독립된 스코프를 갖게 된다. 2. export 키워드모듈은 독립적인 파일 스코프를 갖기 때문에 모듈 내에서 선언한 모든 것들은 기본적으로 해당 모듈 내부에서만 참조가 가능하다. 만약 다른 모듈들이 사용할 수 있게 하고 싶다면 export를 이용하면 가능하다. 12345678910111213141516// lib.js// 변수의 공개export const x = 100;// 함수의 공개export function sum(x) { return x + 10;}// 클래스의 공개export class Person { constructor(name) { this.name = name; }} 선언문 앞에 매번 export 키워드를 붙이기 싫다면 대상을 모아 하나의 객체로 구성하면 한번에 export 할 수 있다. 1234567891011121314// lib.jsconst x = 100;function sum(x) { return x + 10;}class Person { constructor(name) { this.name = name; }}export { x, sum, Person} 3. import 키워드export한 모듈을 로드하려면 export한 이름으로 import해야 한다. 1234567// app.js// 같은 폴더 내의 lib.js 모듈을 로드하낟.import { x, sum, Person} from './lib.js';console.log(x); // 100console.log(sum(10)); // 110console.log(new Person('Choi')); // Person { name: 'Choi'} 각각의 이름을 지정하지 않고 하나의 이름으로 import할 수 있다. 123456// app.jsimport * as lib from './lib.js';console.log(lib.x); // 100console.log(lib.sum(10)); // 110console.log(new lib.Person('Choi')); // Person { name: 'Choi'}","link":"/2019/06/03/til-20190603/"},{"title":"실행컨텍스트","text":"1. 실행컨텍스트실행 컨텍스트는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 변수는 메모리에 저장되는게 아니라 실행 컨텍스트의 객체의 키와 벨류로 저장된다. 1.1. 실행 가능한 코드- 전역코드전역 코드에 var키워드로 선언한 변수는 전역객체의 프로퍼티로 등록된다. let, const는 전역 스코프에 등록된다. 전역 스코프를 생성해야 하며 전역 객체와 연결되어야 한다. (전역 실행 컨텍스트) - 함수코드지역 스코프를 생성해야 하며 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결되어야한다. (함수 실행 컨텍스트) - eval코드자신만의 독자적인 스코프를 생선한다. (eval 실행 컨텍스트) - 모듈 코드모듈 별로 독립적이 스코프를 생성한다. (모듈 실행 컨텍스트) 1. 2. 실행 가능한 코드의 평가와 실행모든 실행 가능한 코드는 실행(런타임)에 앞서 평가(런타임 이전) 과정을 거쳐 코드 실행을 위한 준비를 한다. 코드의 평가 과정에서 실행 컨텍스트가 생성되고 변수, 함수, 클래스 등의 선언문이 평가되어 그 결과가 생성된 실행 컨텍스트에 등록된다. 코드의 평가가 끝나면 비로소 선언문을 제외한 코드가 순차적으로 실행된다. 이때 코드 실행에 필요한 정보를 실행 컨텍스트에서 취득한다. 12345678910111213var x = 1;let y = 2;function foo () { var y = 3 function bar (b) { const z = 5;} bar();}foo(); 평가런타임 이전에 평가를 통해 전역 실행 컨텍스트가 만들어진다. 실행런타임에 실행하면 값의 할당이 이루어진다. 2. 코드의 평가와 실행코드는 실행(런타임)되기 이전에 평가(런타임 이전)된다. 아래의 코드가 평가되고 실행되는 과정을 생각해보자. 123456789101112131415var x = 1;let y = 2;function foo () { var a = 3; var x = 4; const y = 2; function bar () { const z = 5;} bar();}foo(); 2.1. foo 평가와 실행전역코드가 실행되면 foo()함수가 실행되어 foo()함수가 평가된다. 평가 실행 2.2. bar 평가와 실행평가foo()함수가 실행되면 bar()함수가 평가된다. 렉시컬 스코프, 즉 외부 렉시컬 환경 참조(Outer Lexical Enviroment Reference)는 평가되고 있을 때의 실행컨텍스트로 결정된다. bar함수가 평가될 때의 실행컨텍스트는 foo함수다. 이것이 렉시컬 스코프이다. 실행실행단계에서 할당을 위해 자신의 실행컨텍스트의 렉시컬환경의 환경레코드에서 변수 프로퍼티가 있나 찾아 있으면 키값을 할당하고 없으면 외부 렉시컬 환경의 환경레코드로 가서 다시 검색한다. 이것을 스코프 체인이라 한다. 여기서 프로토타입체인은 다른 영역이다.","link":"/2019/06/05/til-20190605/"},{"title":"SPA, Routing","text":"1. SPA(Single Page Application)SPA는 모던 웹의 패러다임이다. 기본적으로 단일 페이지로 구성되어 한 번의 다운로드로 모든 파일을 다 가져와서 첫 로딩속도가 느리고, SEO문제가 좀 있는게 단점이지만 로딩된 후는 깔끔한 화면전환과 깜빡거리지 않는다는 장점이 있다. 2. Routing애플리케이션에서 라우팅이란 사용자가 태스크를 수행하기 위해 어떤 화면에서 다른 화면으로 화면을 전환하는 내비게이션을 관리하기 위한 기능을 의미한다. 브라우저가 화면을 전환하는 경우는 아래와 같다. 브라우저의 주소창에 URL을 입력하면 해당 페이지로 이동한다. 웹페이지의 링크를 클릭하면 해당 페이지로 이동한다. 블라우저의 뒤로가기 또는 앞으로가기 버튼을 클릭하면 사용자가 방문한 웹페이지의 기록의 뒤 또는 앞으로 이동한다. AJAX 요청에 의해 서버로부터 데이터를 응답받아 화면을 생성하는 경우, 브라우저의 주소창의 URL은 변경되지 않는다. 이는 사용자의 방문 history를 관리할 수 없음을 의미하며, SEO(검색엔진 최적화) 이슈의 발생 원인이기도 하다. history 관리를 위해서는 각 페이지는 브라우저의 주소창에서 구별할 수 있는 유일한 URL을 소유하여야 한다. 3. SPA와 Routing 구분 History 관리 SEO 대응 사용자 경험 서버 렌더링 구현 난이도 IE 대응 전통적 링크 방식 O O X O 간단 AJAX 방식 X X O X 보통 Hash 방식 O X O X 보통 PJAX 방식 O O O 세모 복잡 3.1. 전통적 링크 방식장점 구현이 쉽다. 단점 링크태그는 리스폰스와 리퀘스트가 이루어져 서버 렌더링이 다시 일어난다. 3.2. AJAX방식장점 화면이 깜빡이지 않는다. 단점 SEO의 오류가 있다. URL이 바뀌지 않아 히스토리가 남지 않는다. Reload시 첫페이지가 등장한다. 3.3. Hash방식AJAX방식의 단점을 다 보완했지만 URL에 해시태그가 들어가 가독성이 좋지 않다. 3.4. pushState 방식(pjax)모든 문제가 해결되지만 백엔드와의 협업 이 필요하고, 최신브라우저만 지원한다. 이벤트‘DomContentLoaded’ 는 Dom이 로드되면 실행 ‘load’ 모든게 로드되면 실행","link":"/2019/06/11/til-20190611/"},{"title":"Angular 장점, Component 기본","text":"Angular Angular는 SAP(Single Page Application) 개발을 위한 구글의 오픈소스 자바스크립트 프레임워크이다. 기존의 JavaScript가 HTML/CSS가 컨트롤했다면 Angular는 HTML/CSS가 JavaScript를 컨트롤한다고 볼 수 있다. 1. Angular의 장점 1.1. 컴포넌트 기반 개발컴포넌트는 기능별로 나누어 놓은 것을 말한다. 이 기능은 프로젝트가 커질 수록 중요하고 개발 생산성을 높인다. 1.2. TypeScript의 도입Angular는 TypeScript의 도입으로 코드의 가독성을 높이고 예측할 수 있게 하며, 컴파일 단계에서 오류를 포착할 수 있는 장점이 있다. 또한 모듈, 클래스, 인터페이스 등의 강력한 객체 지향 프로그래밍(OOP, Object Oriented Programming) 지원은 크고 복잡한 프로젝트의 코드 기반을 쉽게 구성할 수 있도록 돕는다. 1.3. Digest Loop로 인한 성능저하 문제의 해결AngularJS의 단점 중 대표적인 것이 양방향 데이터 바인딩을 위해 사용되는 Digest Loop로 인한 성능저하였지만 현재는 이 성능 저하가 개선되어 2배이상 빨라졌다. 1.4. Lazy Loading 1.5. 코드 최적화Angular가 버전업 될 때마다 코드 최적화에 힘을 쓰고 있어 현재는 45KB정도의 크기로 축소되었다고 한다. 2. Angular Component컴포넌트는 Angular의 핵심 구성 요소로 애플리케이션의 화면을 구성하는 뷰(view)를 생성하고 관리하는 것이다. Angular는 컴포넌트를 조립하여 하나의 완성된 애플리케이션을 작성한다. 2.1. 웹 컴포넌트컴포넌트 내에서만독립된 스코프를 갖고 유효한 상태 정보와 로직, 스타일을 소유한 완결된 뷰를 생성하기 위한 것이 컴포넌트이다. 컴포넌트는 독립적이고 완결된 뷰를 생성하기 위하여 “HTML, CSS JavaScript를 하나의 단위로 묶는 것”이다. 12345678910111213141516171819// 임포트 영역import { Component } from '@angular/core';// @Component 데코레이터 영역@Component({ selector: 'app-root', template: ` &lt;p&gt;안녕하세요&lt;/p&gt; `, styles: [` p { color: red; } `]})// 컴포넌트 클래스 영역export class AppComponent { title = 'app';} 2.2. 컴포넌트 호출컴포넌트를 호출하기 전에 루트모듈에 클래스명을 등록해야한다. 12345678910111213141516import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppComponent } from './app.component';import { HelloComponent } from './hello/hello.component'; // 1@NgModule({ declarations: [ AppComponent, HelloComponent // 2 ], imports: [BrowserModule], providers: [], bootstrap: [AppComponent]})export class AppModule { } 모듈에 등록 후 다른 컴포넌트의 템플릿에서 해당 컴포넌트의 셀렉터를 태그로 호출하는 방식이있다. 12345678910111213141516171819// 임포트 영역import { Component } from '@angular/core';// @Component 데코레이터 영역@Component({ selector: 'app-root', template: ` &lt;app-home&gt;&lt;/app-home&gt; `, styles: [` p { color: red; } `]})// 컴포넌트 클래스 영역export class AppComponent { title = 'app';}","link":"/2019/06/14/til-20190614/"},{"title":"Angular Component(Built-in-directive)","text":"1. Angular Component (Built-in-directive)디렉티브는 컴포넌트의 공통된 기술을 분리해내는 기술이며 컴포넌트의 복잡도를 낮추고 가독성을 향상시킨다. 셀렉터에서 대괄호로 쓰는 이유는 태그로 사용하는 것이 아닌 어트리뷰트로 사용한다는 것을 명시해준다. 아래 예제는 해당 어트리뷰트를 사용하면 모든 글자를 파란색으로 바꾼다. 1234567891011// text-blue.directive.tsimport { Directive, ElementRef, Renderer2 } from '@angular/core';@Directive({ selector: '[textBlue]'})export class TextBlueDirective { constructor(el: ElementRef, renderer: Renderer2) { // el은 호스트요소가 들어온다. renderer.setStyle(el.nativeElement, 'color', 'blue'); }} 어트리뷰트가 사용된 요소를 호스트요소라 한다. 1.1. ngclass여러개의 클래스를 지정했을 때 기존의 클래스를 덮어쓰지 않는다. 1234567891011&lt;!-- 예 --&gt;&lt;element [ngClass]=\"문자열 | 배열 | 객체\"&gt;...&lt;/element&gt;&lt;!-- 문자열 --&gt;&lt;div [ngClass]=\"'text-bold color-blue'\"&gt;...&lt;/div&gt;&lt;!-- 배열 --&gt;&lt;div [ngClass]=\"['text-bold', 'color-blue']\"&gt;...&lt;/div&gt;&lt;!-- 객체 --&gt;&lt;div [ngClass]=\"{ 'text-bold': true, 'color-blue': false }\"&gt;...&lt;/div&gt; 1.2. ngStyle여러 개의 인라인 스타일을 추가 또는 제거한다. 스타일 바인딩 또한 기존의 것을 덮어쓰지 않고 추가 한다. 12345&lt;!-- 문자열 --&gt;&lt;element [ngStyle]=\"객체\"&gt;...&lt;/element&gt;&lt;!-- 무조건 객체형태 --&gt;&lt;div [ngStyle]=\"{ color: 'red', 'width.px': 100 }\"&gt;&lt;/div&gt; 1.3. ngIf우변의 표현식의 연산 결과가 참이면 호스트 요소를 DOM에 추가하고 거짓이면 제거한다. 반드시 우변은 boolean값이여야 한다. 1234567891011121314151617&lt;!-- 예 --&gt;&lt;ng-template [ngIf]=\"expression\"&gt; &lt;element&gt;...&lt;/element&gt;&lt;/ng-template&gt;&lt;!-- if else --&gt;&lt;element *ngIf=\"expression; else elseBlock\"&gt;Truthy condition&lt;/element&gt;&lt;ng-template #elseBlock&gt;Falsy condition&lt;/ng-template&gt;&lt;!-- if else --&gt;&lt;element *ngIf=\"expression; then thenBlock else elseBlock\"&gt;&lt;/element&gt;&lt;ng-template #thenBlock&gt;Truthy condition&lt;/ng-template&gt;&lt;ng-template #elseBlock&gt;Falsy condition&lt;/ng-template&gt;&lt;!-- if --&gt;&lt;element *ngIf=\"expression; then thenBlock\"&gt;&lt;/element&gt;&lt;ng-template #thenBlock&gt;Truthy condition&lt;/ng-template&gt; 1.4. ngFor배열을 순회하면서 DOM에 추가한다. 123456789101112&lt;!-- 예 --&gt;&lt;element *ngFor=\"let item of items\"&gt;...&lt;/element&gt;&lt;element *ngFor=\"let item of items; let i=index; let odd=odd; trackBy: trackById\"&gt;...&lt;/element&gt;&lt;ng-template ngFor let-item [ngForOf]=\"items\"&gt; &lt;element&gt;...&lt;/element&gt;&lt;/ng-template&gt;&lt;ng-template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\"&gt; &lt;element&gt;...&lt;/element&gt;&lt;/ng-template&gt;","link":"/2019/06/18/til-20190617/"},{"title":"Angular Component(Template Reference Variable, Interection)","text":"1. 템플릿 참조 변수템플릿 참조 변수는 DOM 요소에 대한 참조를 담는다. 해당 요소 내에서 해쉬기호(#)를 변수명 앞에 추가하면 템플릿 참조변수를 선언하며 해당 변수명을 사용해 템플릿 내의 자바스크립트 코드에서 해시기호 없이 참조한다. 템플릿 참조 변수는 템플릿 내에서만 유효하며 컴포넌트 클래스에 어떠한 부수 효과도 주지 않는다. 하지만 템플릿 참조 변수를 이벤트 바인딩을 통해 컴포넌트 클래스로 전달할 수 있다. 1&lt;element #myelement&gt;...&lt;/element&gt; 템플릿 참조 변수를 활용한 예제를 살펴보자. 123456789101112131415161718192021import { Component } from '@angular/core';@Component({ selector: 'app-root', template: ` &lt;div&gt; &lt;!-- 템플릿 참조 변수 input 선언 및 참조--&gt; &lt;input type='text' placeholder=\"enter todo...\" (keyup.enter)=\"add(input)\" #input&gt; &lt;ul&gt; &lt;li *ngfor=\"let todo of todos\"&gt;{{todo}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `})export class AppComponent { todos = [\"HTML\", \"CSS\", \"JavaScript\"]; add(elem: HTMLInputElement) { this.todos = [...todos, elem.value]; }} 1.1. 세이프 내비게이션 연산자세이프 내비게이션 연산자 ?는 컴포넌트 클래스의 프로퍼티 값이 null 또는 undefined일 때 발생하는 에러를 회피하기 위해 사용한다. 1234567891011121314import { Component } from '@angular/core';@Component({ selector: 'app-root', template: ` &lt;!-- obj가 null 또는 undefined일 때 아무것도 표시하지 않는다. --&gt; {{ obj }} &lt;!-- ERROR TypeError: Cannot read property 'id' of undefined --&gt; {{ obj.id }} &lt;!-- 세이프 내비게이션 연산자는 null 또는 undefined의 프로퍼티를 만나면 처리를 종료하고 에러를 발생시키지 않는다. --&gt; {{ obj?.id }} `})export class AppComponent { } 2. Interaction (상호작용)2.1. 컴포넌트의 계층적 트리 구조컴포넌트는 독립적인 존재지만 다른 컴포넌트와 결합도를 유지하지하면서 상태정보를 교환할 수 있어야 한다. 분할된 컴포넌트를 조립한다는 것은 해당 컴포넌트를 다른 컴포넌트에서 사용하는 것을 말한다. 이는 컴포넌트 간에 계층적 구조가 형성될 수 있음을 의미한다. 컴포넌트 간의 부모-자식 관계는 데이터와 공유하기 위해 상태 정보의 흐름을 이어주는 통로로 데이터바인딩과 이벤트바인딩이 사용된다. 이를 사용하기 위해서는 @Input, @Output 데코레이터를 사용해서 받아오고 넘겨줘야한다. 아래 그림은 계층적 트리 구조를 나타낸다. A의 input에서 입력한 정보를 D의 input창에 보이도록 해보자. 우선 A에서 D로 직접적인 연결은 불가하다. 그러기 위해서 A &gt; Root &gt; B &gt; D 순으로 데이터의 이동이 필요하다. 자식이 부모로 보내기 위해서는 이벤트 바인딩과 Output을 사용한다. 12345678910111213// a.component.tsimport { Component, Output } from '@angular/core';@Component({ selector: 'app-a', template: ` &lt;input type=\"text\" (input)=\"fromA.emit($event.target.value)\"&gt; `, styles: []})export class AComponent { @Output() fromA = new EventEmmiter();} A가 보내준 데이터를 Root에서 받는처리를 해야한다. A가 보낸 이벤트 fromA로 이벤트 바인딩을하고 받아온 데이터를 $event를 이용해 받아준다. 부모가 자식(B)로 보낼 때는 프로퍼티바인딩을 사용해서 자식(B)에게 보내준다. 대괄호 안에는 받을 때의 이렇게 받아라 하고 변수명을 지정해준다. 1234567891011121314// app.component.tsimport { Component } from '@angular/core';@Component({ selector: 'app-root', template: ` &lt;app-a (fromA)=\"content = $event\"&gt;&lt;/app-a&gt; &lt;app-b [contentData]=\"content\"&gt;&lt;/app-b&gt; `, styles: []})export class AppComponent { content = '';} B에서 Input 데코레이터를 사용해 데이터를 받아 자식인 D에게 보내준다. 12345678910111213// b.component.tsimport { Component, Input } from '@angular/core';@Component({ selector: 'app-b', template: ` &lt;app-c [contentData]=\"contentData\"&gt;&lt;/app-c&gt; `, styles: []})export class BComponent { @input contentData: string;} 받은 데이터를 프로퍼티 바인딩으로 value에 할당해준다. 12345678910111213// d.component.tsimport { Component, Input } from '@angular/core';@Component({ selector: 'app-d', template: ` &lt;input type=\"text\" [value]=\"contentData\"&gt; `, styles: []})export class BComponent { @input contentData: string;}","link":"/2019/06/18/til-20190619/"},{"title":"WebCafe Markup_01","text":"Semantic Markupschool과정에 앞서 수업의 진도가 빠른 편이라는 이야기를 듣고 기본적인 html, css, javascript 인터넷 강의를 미리 보았다. 인터넷 강의를 들고 클론 코딩을 진행할 때는 디자인적인 측면 즉, 왼쪽에서 오른쪽, 위에서 아래로 식의 시각적인 코딩을 했다. 수업은 Semantic Markup 즉, 의미론적 마크업을 기본으로 진행했다. 의미론적 마크업이란, seo와 웹접근성이 기본이 되는 마크업이다. 예제는 강사님이 수업을 위해 준비하신 웹카페 사이트를 시멘틱마크업을 준수하여 클론코딩을 하는 것이다. body 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Web Cafe&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;header class=\"header\"&gt; &lt;/header&gt; &lt;div class=\"visual\"&gt; &lt;/div&gt; &lt;main class=\"main\"&gt; &lt;/main&gt; &lt;article class=\"slogon\"&gt; &lt;/article&gt; &lt;div class=\"footer-bg\"&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 사진은 강사님의 수업을 듣고 페이지의 영역을 나눠 구분하고 의도에 맞는 태그를 사용해 마크업 하였다. class=&quot;container&quot; 하위요소들을 굳이 안묶어도 되지만 묶어줬다. class=&quot;header&quot; 사이트 네비게이션이나 페이지에 대한 정보를 담는 태그로, 페이지 상단에 위치 하는 &lt;header&gt; 를 사용했다. class=&quot;visual&quot; 장식용 영역이라 마크업에 의미를 두지 않았다. class=&quot;main&quot; 사이트의 주요한 내용을 담는 영역인 &lt;main&gt; 태그를 사용했다. class=&quot;slogon&quot; 블로그 글, 신문 기사와 같은 독립적 컨텐츠를 담는 &lt;article&gt; 태그를 사용해 싸이트의 독립적 컨텐츠 영역임을 명시해줬다. class=&quot;footer-bg&quot; class=&quot;footer&quot;를 view 포트 기준으로 background 를 위해 사용했다. class=&quot;footer&quot; 문서의 꼬릿말임을 알려주는 &lt;footer&gt; 태그를 사용했다. 새롭게 알게 된 사실 수업을 듣기 전에는 모든 영역을 의미없는 그룹태그인 &lt;div&gt; 로 감싸고 class=&quot;header&quot; 형식의 사람의 눈으로만 구분이 가능한 클래스 이름으로 영역을 구분했다. HTML은 컴퓨터언어이기 떄문에 사람의 눈으로 생각하지말고 컴퓨터가 의미에 맞게 해석할 수 있는 마크업 해야한다고 하셨다.","link":"/2019/04/09/webcafe-01-body/"},{"title":"WebCafe Markup_02","text":"header 위에 헤더를 영역별로 구분한걸 토대로 그림을 선형적인 구조로 그려봤다. Markup 순서 h1 - 사이트의 제목이 가장먼저 등장해야 된다고 생각했다. ul.member - 메뉴 영역으로 가기전 로그인, 회원가입등이 먼저 진행된다고 생각됐다. nav.navigation - 위에 2개를 하고 남은 걸 마지막으로 뒀다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;header class=\"header\"&gt; &lt;h1 class=\"logo\"&gt; &lt;a href=\"#\"&gt;&lt;img src=\"logo.log\" alt=\"Web Cafe\"&gt;&lt;/a&gt; &lt;/h1&gt; &lt;ul class=\"member\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;홈&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;로그인&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;회원가입&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;사이트맵&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;ENGLISH&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;nav class=\"navigation\"&gt; &lt;h2 class=\"readable-hidden\"&gt;메인메뉴&lt;/h2&gt; &lt;ul class=\"menu\"&gt; &lt;li class=\"menu-item\" tabindex=\"0\"&gt; &lt;h3 class=\"menu-item-text\"&gt;HTML에 대해&lt;/h3&gt; &lt;ul class=\"sub-menu1 sub-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;HTML5 소개&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;레퍼런스 소개&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;활용예제&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\" tabindex=\"0\"&gt; &lt;h3 class=\"menu-item-text\"&gt;CSS에 대해&lt;/h3&gt; &lt;ul class=\"sub-menu2 sub-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;CSS 소개&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;CSS2 VS CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;CSS 애니메이션&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;CSS Framework&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\" tabindex=\"0\"&gt; &lt;h3 class=\"menu-item-text\"&gt;웹 표준&lt;/h3&gt; &lt;ul class=\"sub-menu3 sub-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;웹 표준 이란?&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;W3C&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;HTML5 현재와 미래&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\" tabindex=\"0\"&gt; &lt;h3 class=\"menu-item-text\"&gt;웹 접근성&lt;/h3&gt; &lt;ul class=\"sub-menu4 sub-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;웹 접근성의 개요&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;장애 환경의 이해&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;장차법&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;웹 접근성 품질마크&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\" tabindex=\"0\"&gt; &lt;h3 class=\"menu-item-text\"&gt;묻고 답하기&lt;/h3&gt; &lt;ul class=\"sub-menu5 sub-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;묻고 답하기&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;FAQ&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1대1 질문&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;웹표준&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;웹 접근성&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\" tabindex=\"0\"&gt; &lt;h3 class=\"menu-item-text\"&gt;자료실&lt;/h3&gt; &lt;ul class=\"sub-menu6 sub-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;공개 자료실&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;웹표준 자료실&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;이미지 자료실&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;웹접근성 자료실&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; class=&quot;logo&quot; 제목을 나타내는 &lt;h1&gt; 태그를 사용했다. 또, 로고 이미지는 배경이 아니라 로고자체의 의미를 가지고 있는 것 같아 &lt;img&gt; 를 사용해 markup에 포함시키고, 링크사용을 위해 &lt;a&gt;를 사용했다. class=&quot;member&quot; 순서에 상관없는 목록화를 위해 &lt;ul&gt; 을 사용하고, &lt;a&gt; 를 포함한 &lt;li&gt; 를 사용했다. class=&quot;navigation&quot; 사이트의 주요 네비게이션 역할을 담는 태그인 &lt;nav&gt; 를 사용하고, 스크린리더 사용자를 위해 &lt;h2&gt;를 사용해 제목을 명시해줬다. 이때, 제목은 CSS를 이용해 시각적으로 보이지 않게 작업했다.메뉴는 &lt;ul&gt;,&lt;li&gt;을 사용했고, 키보드의 tab 접근을 위해 tabindex=&quot;0&quot; 속성을 사용했다. 또한, 메뉴의 &lt;li&gt; 안에 서브메뉴 &lt;ul&gt;, &lt;li&gt;를 사용하고, &lt;a&gt;로 감싸줬다. 이떄, 서브메뉴의 제목은 시각적으로도 보이기 떄문에 서브메뉴 &lt;ul&gt; 의 자식으로 &lt;h3&gt;을 사용해 작업했다. 새롭게 알게 된 사실 로고는 &lt;img&gt; 만 쓰고 그냥 넘겼는데 로고의 의미를 정확히 알고 &lt;h1&gt; 을 사용했다. 메인메뉴를 만들 때 &lt;div&gt; 를 사용했는데 &lt;nav&gt;를 사용했다. 눈으로는 안보이지만 &lt;nav&gt; 가 무엇인지 알려줘야 해서 &lt;h2&gt; 를 사용해 메인메뉴의 제목을 정의 해줬다.","link":"/2019/04/10/webcafe-02-header/"},{"title":"WebCafe Markup_03","text":"&lt;main&gt; Markup 1234567891011&lt;main class=\"main\"&gt; &lt;div class=\"group1\"&gt; &lt;/div&gt; &lt;div class=\"group2\"&gt; &lt;/div&gt; &lt;div class=\"group3\"&gt; &lt;/div&gt;&lt;/main&gt; class=&quot;group1&quot;, class=&quot;group2&quot;, class=&quot;group3&quot; CSS 작업의 편의를 위해 각 영역을 나눠주었다. class=&quot;group1&quot; Markup 1234567891011&lt;div class=\"group1\"&gt; &lt;section class=\"login\"&gt; &lt;/section&gt; &lt;section class=\"validation\"&gt; &lt;/section&gt; &lt;section class=\"term\"&gt; &lt;/section&gt;&lt;/div&gt; class=&quot;login&quot;, class=&quot;validation&quot;, class=&quot;term&quot; 눈에 보이는 순서로 Markup 해도 정보전달에 무리가 없다고 판단했다. class=&quot;login&quot; Markup 로그인섹션을 선형적인 구조로 그려보고 마크업했다.123456789101112131415161718192021&lt;section class=\"login\"&gt; &lt;h2 class=\"login-heading\"&gt;로그인&lt;/h2&gt; &lt;form action=\"#\" method=\"POST\"&gt; &lt;fieldset&gt; &lt;legend&gt;회원 로그인 폼&lt;/legend&gt; &lt;div class=\"user-email\"&gt; &lt;!-- 나중에 디자인적으로 움직이기 편하게 그룹화했다. --&gt; &lt;label for=\"user-email\"&gt;아이디&lt;/label&gt; &lt;input type=\"email\" id=\"user-email\" name=\"uid\" required placeholder=\"이메일 주소\"&gt; &lt;/div&gt; &lt;div class=\"user-pw\"&gt; &lt;label for=\"user-pw\"&gt;비밀번호&lt;/label&gt; &lt;input type=\"password\" id=\"user-pw\" name=\"upw\" required placeholder=\"8자리 이상\"&gt; &lt;/div&gt; &lt;button class=\"btn-login\" type=\"submit\"&gt;로그인&lt;/button&gt; &lt;!-- 로그인 버튼 --&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;ul class=\"sign\"&gt; &lt;!-- 리스트가 괜찮을 것 같아서 리스트로 그룹화해주었다. --&gt; &lt;li&gt;&lt;a href=\"#\"&gt;회원가입&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;아이디/비밀번호 찾기&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt; &lt;section&gt; 문서의 일반적인 구획을 나타내는 컨텐츠 그룹인 &lt;section&gt; 은 &lt;h&gt; 를 자식요소로 포함해야 한다. &lt;form&gt; &lt;form&gt;은 &lt;input&gt;이 있을 경우 사용하게 되는데, 데이터를 보내기 위함이다.또한, 같은 목적을 가진 위젯을 그룹화하는 &lt;fieldset&gt; 을 포함하고 &lt;fieldset&gt;의 라벨인 &lt;legend&gt; 를 같이 사용해야 한다. &lt;input&gt; &lt;input&gt; 과 &lt;label&gt;은 세트로 지정해줘야 한다.여기서 &lt;label&gt;인 아이디(text)를 클릭하면 &lt;input&gt;으로 바로 연결되는 효과를 얻을 수 있다. name=&quot;text&quot; 서버로 데이터를 보낼 때 name 값으로 보낸다고 한다. required &lt;input&gt; 창을 필수로 입력하라는 텍스트를 보여준다. placeholder=&quot;text&quot; &lt;input&gt; 창에 해당 영역의 역할을 텍스트로 보여준다. class=&quot;vaildation&quot; Markup 1234567&lt;section class=\"validation\"&gt; &lt;h2&gt;유효성 검사 배너&lt;/h2&gt; &lt;!--- &lt;section&gt; 사용시 제목이 필수라 나중에 안보이게 처리해야함 ---&gt; &lt;ul class=\"validation-list\"&gt; &lt;li&gt;&lt;a href=\"https://validator.w3.org/\" target=\"_blank\" title=\"마크업 유효성 검사 배너 링크(새창)\"&gt;W3C Markup Validation&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.css-validator.org/#validate_by_upload\" target=\"_blank\" title=\"CSS 유효성 검사 배너 링크(새창)\"&gt;CSS Validation Service&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt; target=&quot;_blacnk&quot; &lt;a&gt; 태그 사용시 target=&quot;_blacnk&quot; 속성을 사용하면 새창에서 열기가 가능하다. title=&quot;text&quot; 텍스트에 마우스오버를 하면 텍스트를 설명해주는 툴팁이 열린다. class=&quot;term&quot; Markup 1234567891011121314&lt;section class=\"term\"&gt; &lt;h2 class=\"term-heading\"&gt;웹 관련 용어&lt;/h2&gt; &lt;dl class=\"term-list\"&gt; &lt;dt class=\"term-list-subject\"&gt; &lt;a href=\"#\"&gt;웹 표준 이란?&lt;/a&gt; &lt;/dt&gt; &lt;dd class=\"term-list-thumbnail\"&gt; &lt;img src=\"images/web_standards.gif\" alt=\"W3C 로고\"&gt; &lt;/dd&gt; &lt;dd class=\"term-list-brief\"&gt; W3C 단체에서 규정한 웹 기술 사양에 대한 규칙을 말하며 표준 규격은... &lt;/dd&gt; &lt;/dl&gt;&lt;/section&gt; &lt;dl&gt;, &lt;dt&gt;, &lt;dd&gt; &lt;dl&gt; 용어를 설명하는 목록을 만드는 태그이고, 자식요소로 용어의 제목인 &lt;dt&gt; 태그와, 용어를 설명하는 태그인 &lt;dd&gt; 를 두어야 한다. alt=&quot;text&quot; 이미지를 사용하면 무조건 대체텍스트인 alt 속성을 줘야한다. 새롭게 알게 된 사실 입력창 옆에 글자를 클릭하면 자동으로 입력창으로 가는게 신기했는데 &lt;label&gt; 을 사용하면 가능하다는 것을 알았다. 입력창 안에 글자는 CSS로 작업하는 줄 알았는데 &lt;input&gt; 의 속성인 required placeholder=&quot;text&quot; 로 가능하다는 것을 알았다. 필요에 따라 target=&quot;_blacnk&quot; 속성을 사용해 새창으로 열기가 가능하다는 것을 알았다. 용어를 설명하는 목록 태그인 &lt;dl&gt;, &lt;dt&gt;, &lt;dd&gt; 새롭게 알게되었다.","link":"/2019/04/11/webcafe-03-main/"},{"title":"WebCafe Markup_04","text":"class=&quot;&quot;group2 Markup 12345678&lt;div class=\"group2\"&gt; &lt;form action=\"\" class=\"search\"&gt;&lt;/form&gt; &lt;div class=\"board\"&gt; &lt;section class=\"notice\"&gt;&lt;/section&gt; &lt;section class=\"pds\"&gt;&lt;/section&gt; &lt;/div&gt; &lt;section class=\"news\"&gt;&lt;/section&gt;&lt;/div&gt; Markup 순서 class=&quot;search&quot; class=&quot;board&quot; class=&quot;news&quot; class=&quot;search&quot; Markup 위의 폼영역을 보고 선현적구조로 설계해봤다.12345678910&lt;form action=\"#\" method=\"post\" class=\"search\"&gt; &lt;fieldset&gt; &lt;legend&gt;검색 폼&lt;/legend&gt; &lt;div class =\"search-container\"&gt; &lt;label for=\"search-input\"&gt;자료검색&lt;/label&gt; &lt;input id=\"search-input\" class=\"search-input\" type=\"search\" required placeholder=\"검색어를 입력하세요.\"&gt; &lt;button class=\"search-btn\"&gt;검색&lt;/button&gt; &lt;/div&gt; &lt;/fieldset&gt;&lt;/form&gt; class=&quot;search&quot; &lt;input&gt; 사용을 위해 &lt;form&gt; 을 사용했다. action=&quot;#&quot; 데이터전달을 위해 보낼 곳의 주소를 써주는 곳이다. method=&quot;post&quot; 서버의 값이나 상태를 바꾸기 위한 상태이다. class=&quot;search-container&quot; 안쪽 검색영역의 디자인을 위해 &lt;div&gt;를 사용했다. class=&quot;board&quot; Markup 위의 board 영역을 보고 선현적구조로 설계해봤다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;div class=\"board\"&gt; &lt;section class=\"notice board-act\"&gt; &lt;!-- 나중에 동적인 움직임을 주기 위한 board-act 클래스 추가 --&gt; &lt;h2 id=\"notice\" class=\"tab notice-heading\" tabindex=\"0\"&gt;공지사항&lt;/h2&gt; &lt;ul class=\"board-list notice-list\"&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;!-- fonttelo를 이용해 아이콘 삽입을 위한 클래스 --&gt; &lt;a href=\"#\"&gt;HTML의 모든 것을 알려주마 샘플 활용법&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;W3C 사이트 리뉴얼 및 공지사항&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;KWCAG 2.1 소식&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;서버 점검으로 인한 사이트 이용안내 입니다.&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;여러분들이 생각하는 웹 접근성에 대해 이야기를 나누어 봅시다.&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a href=\"#\" class=\"icon-plus board-more notice-more\" title=\"공지사항\" aria-labelledby=\"notice\"&gt;더보기&lt;/a&gt; &lt;/section&gt; &lt;section class=\"pds\"&gt; &lt;h2 id=\"pds\" class=\"tab pds-heading\" tabindex=\"0\"&gt;자료실&lt;/h2&gt; &lt;ul class=\"board-list pds-list\"&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;디자인 사이트 링크 모음&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;웹 접근성 관련 자료 모음&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;예제 샘플 응용해보기&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;웹 접근성 향상을위한 국가 표준 기술 가이드라인&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;로얄티 프리 이미지 자료&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a href=\"#\" class=\"icon-plus board-more pds-more\" title=\"자료실\" aria-labelledby=\"pds\"&gt;더보기&lt;/a&gt; &lt;/section&gt;&lt;/div&gt; &lt;div&gt; 영역안에 2개의 &lt;section&gt; 을 넣어준 이유는 디자인면에서 한개의 영역으로 보이지만 나중에 CSS작업으로 2개를 겹치게 작업할 것이다. 더보기는 디자인면에서 제목 다음으로 나와야 할 것 같지만 목록을 읽고난 다음 더보기를 누르지, 읽기 전에 누르지 않기 때문에 가장 밑에 markup했다. class=&quot;news&quot; Markup 123456789101112131415&lt;section class=\"news\"&gt; &lt;h2 class=\"news-heading\"&gt;새소식&lt;/h2&gt; &lt;article class=\"news-item\"&gt; &lt;a href=\"#\"&gt; &lt;h3 class=\"news-item-subject\"&gt;W3C 사이트가 리뉴얼 되었습니다.&lt;/h3&gt; &lt;time class=\"news-item-date\" datetime=\"2019-04-11T11:19:37\"&gt;2019.04.11&lt;/time&gt; &lt;p class=\"new-item-brief\"&gt;디자인 및 다양한 view 환경을 고려하여 구성되어 있으며, 기존보다 최신 정보 및 개발자를 위한 기술 가이드도 찾기 쉽도록 구성되어 있습니다.&lt;/p&gt; &lt;figure class=\"news-item-thumbnail\"&gt; &lt;img src=\"images/news.gif\" alt=\"\"&gt; &lt;figcaption&gt;W3C 리뉴얼&lt;/figcaption&gt; &lt;/figure&gt; &lt;/a&gt; &lt;/article&gt; &lt;a class=\"news-more icon-plus\" href=\"#\" title=\"새소식\" target=\"_blank\"&gt;더보기&lt;/a&gt;&lt;/section&gt; #","link":"/2019/04/12/webcafe-04-group2/"},{"title":"WebCafe Markup_05","text":"class=&quot;group3&quot; Markup 12345678&lt;div class=\"group group3\"&gt; &lt;div class=\"event-related\"&gt; &lt;/div&gt; &lt;section class=\"favorite\"&gt; &lt;/section&gt;&lt;/div&gt; class=&quot;event-related&quot; Markup 1234567891011121314151617181920212223&lt;div class=\"event-related\"&gt; &lt;section class=\"event\"&gt; &lt;h2 class=\"event-heading\"&gt;신규 &lt;span&gt;이벤트&lt;/span&gt;&lt;/h2&gt; &lt;!-- 디자인을 위한 &lt;span&gt; --&gt; &lt;div class=\"event-detail\"&gt; &lt;p&gt;&lt;img class=\"event-thumbnali\" src=\"images/free_gift.gif\" alt=\"이벤트 경품 : 웹표준 핵심가이드북 2 도서 증정\"&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;웹표준 핵심 가이드북 2 출시!&lt;/em&gt; 선착순 500명 한정으로 증정.&lt;/p&gt; &lt;/div&gt; &lt;div class=\"event-btn\"&gt; &lt;button class=\"event-btn-prev\" aria-label=\"이전 이벤트 보기\"&gt;&lt;/button&gt; &lt;button class=\"event-btn-next\" aria-label=\"다음 이벤트 보기\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=\"related\"&gt; &lt;h2 class=\"related-heading\"&gt;관련 &lt;span&gt;사이트&lt;/span&gt;&lt;/h2&gt; &lt;ul class=\"related-list\"&gt; &lt;!-- CSS 속성인 transition 으로 dropdown 효과를 연출할 것임. --&gt; &lt;li&gt;&lt;a href=\"#\"&gt;패스트 캠퍼스&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;W3C&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;CSS ZenGarden&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;웹접근성 연구소&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Web Standards&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/div&gt; 편리한 CSS 작업을 위해 신규이벤트와 관련사이트를 하나의 &lt;div&gt;로 묶어주고, 각각 &lt;section&gt; 으로 지정해주었다. &lt;div class=&quot;event-detail&quot;&gt; 에 들어있는 내용을 읽은 후 동작이 필요하기 때문에 &lt;div class=&quot;event-detail&quot;&gt; &gt; &lt;div class=&quot;event-btn&quot;&gt; 순으로 Markup 해주었다. 나중에 CSS 작업을 위해 내용이 들어있는 &lt;div class=&quot;event-detail&quot;&gt;와 버튼이 들어있는 &lt;div class=&quot;event-btn&quot;&gt; 으로 영역을 나눠주었다. &lt;button&gt;의 경우 CSS를 이용해 sprites기법을 사용할 것이다. sprites기법 : 이미지를 불러오는 방법중 하나로 서버로의 요청 횟수를 최소화할 수 있는 것이 장점이다. class=&quot;favorite&quot; Markup 12345678910&lt;section class=\"favorite\"&gt; &lt;h2 class=\"favorite-heading\"&gt;인기 &lt;span&gt;사이트&lt;/span&gt;&lt;/h2&gt; &lt;ol class=\"favorite-list\"&gt; &lt;li class=\"no1\"&gt;&lt;a href=\"#\"&gt;W3C&lt;/a&gt;&lt;em class=\"up\"&gt;상승&lt;/em&gt;&lt;/li&gt; &lt;li class=\"no2\"&gt;&lt;a href=\"#\"&gt;CSS Zen Garden&lt;/a&gt;&lt;em class=\"down\"&gt;하락&lt;/em&gt;&lt;/li&gt; &lt;li class=\"no3\"&gt;&lt;a href=\"#\"&gt;MDN&lt;/a&gt;&lt;em class=\"stop\"&gt;멈춤&lt;/em&gt;&lt;/li&gt; &lt;li class=\"no4\"&gt;&lt;a href=\"#\"&gt;Web Standards&lt;/a&gt;&lt;em class=\"up\"&gt;상승&lt;/em&gt;&lt;/li&gt; &lt;/ol&gt; &lt;a href=\"#\" class=\"favorite-more icon-plus\" title=\"인기 사이트\"&gt;더보기&lt;/a&gt;&lt;/section&gt;","link":"/2019/04/13/webcafe-05-group3/"},{"title":"WebCafe Markup_06","text":"class=&quot;slogan&quot; Markup 12345678910&lt;article class=\"slogan\"&gt; &lt;h2 class=\"slogan-heading\" title=\"웹 카페에서 퉵 표준을\"&gt;슬로건&lt;/h2&gt; &lt;p class=\"slogan-content\"&gt; &lt;q cite=\"https://w3.org\"&gt;The power of the Web is in its universality, Access by everyone regardless of disability is an essential aspect.&lt;/q&gt; Tim Berners - Lee , W3C Director and inventor of the World Wide Web &lt;/p&gt; &lt;footer class=\"readable-hidden\"&gt; &lt;!-- 나중에 css작업으로 내용을 안보이게 하는 readable-hidden 클래스를 부여해줬다. --&gt; 출처 : World Wide Web Consortium &lt;/footer&gt;&lt;/article&gt; class=&quot;article&quot; class=&quot;sologan-heading &lt;h2&gt; 를 사용해서 제목을 지정하고, 배경이미지가 로드안될 상황을 대비해 텍스트를 넣어주었다.배경이미지는 sprite기법 을 사용할 것이고, title 속성을 이용해 이미지에 설명을 더해주었다. class=&quot;slogan-content&quot; &lt;h2&gt; 의 내용인 &lt;p&gt; 를 사용하여, 제목의 문단임을 명시해줬다. 또, &lt;q&gt; 를 사용해인용구임음 명시해주고 어디서 가져왔는지 site 속성을 #### 이용해 한 번더 알려주었다. &lt;footer&gt; &lt;footer&gt; 의 사용이 &lt;body&gt; 에만 국한되지 않고 그룹이 모여있는 곳이면 사용할 수 있다는 것을확인하는 차원에서 사용했고, 여기에는 출처를 한 번더 명시해줬다. 새롭게 알게 된 사실 인용문 전용 태그인 &lt;q&gt; 가 있다는 사실을 알게되었다. &lt;footer&gt; 의 사용이 자유롭다는 것을 알게되었다.","link":"/2019/04/14/webcafe-06-slogan/"},{"title":"WebCafe Markup_07","text":"class=&quot;footer&quot; Markup 123456789101112131415161718192021222324&lt;div class=\"footer-bg\"&gt; &lt;footer class=\"footer\"&gt; &lt;a class=\"footer-logo\" href=\"#\"&gt;&lt;img src=\"images/footer_logo.png\" alt=\"Web Cafe\"&gt;&lt;/a&gt; &lt;ul class=\"guide-list\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;회사 소개&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;개인정보 보호정책&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;이메일주소 무단수집 거부&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;contact us&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;site map&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;address class=\"address\"&gt; &lt;span&gt;서울시 강남구 역삼동 718-5&lt;/span&gt; &lt;span&gt;전화 : 02-3429-5114&lt;/span&gt; &lt;span&gt;email : &lt;a href=\"mailto:sungjin0864@gmail.com\"&gt;sungjin0864@gmail.com&lt;/a&gt;&lt;/span&gt; &lt;/address&gt; &lt;small class=\"copyright\"&gt; Copyright since &amp;copy; 2010 by Web Cafe CORPORATION ALL RIGHTS RESERVED. &lt;/small&gt; &lt;div class=\"badge\"&gt; &lt;img src=\"images/html5_logo.png\" alt=\"최신 표준 마크업인 HTML5 기술을 적용했습니다.\"&gt; &lt;img src=\"images/css3_logo.png\" alt=\"최신 표준 스타일인 CSS3 기술을 적용했습니다.\"&gt; &lt;/div&gt; &lt;/footer&gt;&lt;/div&gt; class=&quot;footer-bg&quot; class=&quot;footer 의 배경을 view포트 크기에 맞추기 위한 빈 박스를 만들어주었다. class=&quot;footer 눈에 보이는 순서대로 Markup 해도 정보전달에 장애가 있지 않아 그대로 Markup 해주었다.class=&quot;footer 에 제목을 주지 않은 이유는 footer 는 제목을 넣을 필요가 없다고 하셔서 Markup 에서 제외했다. class=&quot;guide-list&quot; 순서에 의미를 부여하지 않는 &lt;ul&gt; 을 사용하고 링크의 이동을 위해 &lt;li&gt; 의 자식으로 &lt;a&gt; 를 사용했다. class=&quot;address&quot; &lt;address&gt; 를 사용해 주소영역이라는 걸 명시해주고, 각 요소의 디자인을 위해 &lt;span&gt; 을 사용했다.또, email 을 누르면 내 메일을 바로 연결하기 위해 &lt;a&gt; 의 href=&quot;mailto:[email]&quot; 을 사용했다. class=&quot;copyright&quot; 저작권 영역임을 명시하기 위해 &lt;small&gt; 을 사용하고, 에디터, 브라우저의 버젼 및 호환성을 고려해카피아이콘은 특수문자 코드인 &amp;copy 를 사용했다. class=&quot;badge&quot; CSS 작업의 편의를 위해 2개의 &lt;img&gt; 를 &lt;div&gt;로 감싸주었고, 신기술을 사용했다는자랑을 하기위해 대체텍스트는 위와 같이 적어주었다.","link":"/2019/04/15/webcafe-07-footer/"},{"title":"예습","text":"1. 자바스크립트 실행 환경 브라우저와 node.js는 자바스크립트를 해석하고 실행할 수 있는 v8엔진을 내장하고 있다. 기본적으로 브라우저에서 동작하는 코드는 node.js 환경에서도 동작한다. 하지만 브라우저와 node.js의 존재 목적은 다르다. 1.1. 브라우저 HTML, CSS, JavaScript를 실행하여 웹페이지를 화면에 렌더링하는 것이 주된 목적이다. ECMAScript(core javascript)를 실행할 수 있다. 브라우저가 제공하는 Wep API를 사용할 수 있다. 따라서, 사용자의 컴퓨터에 파일 생성이 불가하다. 1.2. node.js 서버 개발 환경을 제공하는 것이 주된 목적이다. ECMAScript(core javascript)를 실행할 수 있다. node.js가 제공하는 고유의 API를 사용할 수 있다. 2. 웹 브라우저는 어떻게 동작하는가?구글의 v8엔진의 등장으로 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되는 범용 개발 언어가 되었다. 하지만 가장 많이 사용되는 분야는 역시 웹 브라우저 환경에서 동작하는 웹 페이지/애플리케이션이다 브라우저의 핵심 기능은 사용자가 참조하고자 하는 웹 페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것이다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(parsing)되어 DOM, CSSOM 트리로 변환되고 Render트리로 결합된다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 표시한다. 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 제어 권한을 넘겨 받은 자바스크립트 엔진은 모든 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨 브라우저가 중지 됐던 시점부터 DOM 생성을 재개한다. 이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, JavaScript 를 처리한다. 이것은 script 태그의 위치에 따라 블로킹이 발생하여 DOM 생성이 지연될 수 있다는 것을 의미한다. 2.1. node.js구글 chrome v8 자바스크립트 엔진으로 빌드된 자바스크립트 런타인 환경(Runtime Environment)이다. 간단히 말하면 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바 스크립트 실행 환경이 node.js 이다. 3. 변수란 무엇인가? 왜 필요한가?10+20 을 예로 들어보자. 숫자 값 10과 20은 메모리 상의 임의의 위치에 기억되고, 연산 결과로 생성된 숫자 값 30도 메모리 상의 임의의 위치에 저장된다. 성공적으로 연산이 끝났고 연산 결과도 메모리에 저장됐지만 연산하여 만들어낸 숫자 값30을 재사용할 수 없다는 문제가 있다. 만약 결과 값 30을 재사용하고 싶다면 저장된 메모리 공간의 주소에 직접 접근하는 것 이외에는 방법이 없다. 하지만 메모리 주소로 메모리에 직접 접근하는 것은 시스템을 멈추게 할 수도 있는 치명적 오류를 생산할 가능성이 높은 매우 위험한 일이다. 따라서 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다. 기억하고 싶은 데이터를 메모리에 저장하고, 저장된 데이터를 읽어 들여 재사용하기 위해 프로그래밍 언어는 변수를 제공한다. 변수(variable)는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 간단히 말하자면 변수는 값을 저장하고 참조하는 메커니즘으로 값에 이름을 붙인 것이다. 번수를 통해 개발자는 메모리 주소를 직접 다루지 않아아도 값을 저장하거나 참조할 수 있고 값을 변경할 수도 있다. 변수에 값을 저장하는 것을 할당(assignment 대입, 저장)이라 하고, 변수에 저장된 값을 읽어 들이는 것을 참조(reference)라고 한다. 변수는 사람의 언어로 기술한 변수명을 통해 저장된 값의 의미를 명확히 할 수 있다. 따라서 코드의 가독성을 높여주는 부수적이 효과도 얻을 수 있다. 3.1. 변수 선언변수 선언(variable declaration)이란 변수명(식별자)을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다. 변수를 선언할 때는 var, let, const 키워드를 사용한다. 변수를 선언하고 변수 값을 할당하지 않으면 자바스크립트 엔진에 의해 undefined 라는 값이 암묵적으로 할당되어 초기화된다. 이것은 자바스크립트의 독특한 특징이다. 자바스크립트 엔진은 변수 선언을 아래의 2단계를 거쳐 수행한다. 선언 단계(Declaration phase) : 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 실행 컨텍스트 : 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 초기화 단계(Initialization phase) : 값을 저장하기 위해 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다. var score;는 선언단계를 통해 변수명 score를 등록하고, 초기화 단계를 통해 변수 score에 암묵적으로 undefined를 할당하여 초기화한다. 만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값(Gavage value)이라 한다. 따라서 메모리 공간을 확보한 다음 값을 할당하지 않은 상태에서 곧바로 변ㄷ수값을 참조하면 쓰레기 값이 나올 수 있다. ReferenceError 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 참조 에러다.(변수를 사용하려면 반드시 선언이 필요하다.) 3.2. 변수 선언의 실행 시점과 변수 호이스팅12console.log(score);var score; 위의 예제를 살펴보면 console.log(score) 가 먼저 실행된다. 하지만 console.log(score) 가 실행되는 시점에는 아직 변수 score의 선언이 실행되지 않았으므로 참조 에러(ReferenceError)가 발생할 것처럼 보인다. 하지만 참조 에러는 발생하지 않고 undefined가 출력된다. 변수 선언은 소스 코드가 순차적으로 한줄씩 실행되는 시점(런타임, run-time)이 아니라 그 이전(파싱 타임, parsing-time)에 먼저 실행된다. 즉 자바스크립트 엔진은 소스 코드를 한줄씩 순차적으로 실행하기 이전에 먼저 소스 코드 전체를 평가한다. 이때 모든 선언문을 찾아내어 식별자를 등록하고 초기화한다. 그후, 선언문을 제외한 소스 코드를 한줄씩 순차적으로 실행한다. 런타임 : 소스 코드가 순차적으로 한줄씩 실행되는 시점 파싱타임 : 소스 코드가 실행되기 이전 위 예제와 같이 변수선언이 되기 이전에 console.log(score)가 실행되므로 참조에러가 발생해야 한다. 하지만 undefined가 출력된다. 이는 변수 선언이 다른 코드가 실행되기 이전에 먼저 실행된다는 증거이다. 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)이라 한다. 3.3. 값의 할당변수에 값을 할당(assignment 대입, 저장)할 때는 할당 연산자(=)를 사용한다. 할당 연산자는 우변의 값을 좌변으 변수에 할당한다. 변수 선언은 다른코드가 실행되기 이전, 즉 파싱타임에 먼저 실행되지만 값의 할당은 코드가 순차적으로 실행되는 시점인 런타임에 실행된다. 즉 자바스크립트 엔진은 변수의 선언과 값의 할당을 분리해서 각각 실행한다. 3.4. 값의 재할당var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수가 저장하고 있는 값을 버리고 새로운 값을 저장하는 것이다. 변수에 값을 재할당하면 변수 score는 이전 값 80에서 재할당 값 90으로 변경된다. 처음 할당됐던 공간을 지우는게 아니라 새로운 공간을 확보하고 그 메모리에 새로운 값을 저장한다. 변수 값을 재할당하면 그전에 있던 값들은 변수를 가지고 있지 않다. 이것은 더이상 이전의 값이 필요없다는 것을 의미한다. 아무도 사용하고 있지 않는 불필요한 값들은 가비지 컬렉터(Garbage Collector)에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제될 지는 예측할 수 없다. ES6에서 도입된 const 키워드로 선언한 변수는 재할당이 금지된다. 따라서 const 키워드를 사용하면 상수를 표현할 수 있다. 3.5. 식별자 네이밍 규칙식별자(identifier)는 어떤 데이터를 식별해낼 수 있는 고유한 이름이다. 식별자는 아래와 같은 네이밍 규칙을 준수해야한다. 식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다. 단, 식별자는 숫자로 시작하는 것은 허용하지 않고, 특수문자를 제외한 문자, underscore( _ ), 달러 기호($)로 시작해야 한다. 변수명도 식별자이므로 위 네이밍 규칙을 따라야 한다. 변수는 쉼표( , )로 구분해 하나의 문에서 여러 개를 한번에 선언할 수 있다. 하지만 가독성이 나빠지므로 권장하지 않는다. 1var person, $elem, _name, first_name, val3; 자바스크립트는 대소문자를 구별하므로 아래의 변수는 각각 별개의 변수이다. 123var fistname;var firstName;var FIRSTNAME; 단어를 한눈에 구분하기 위해 자주 사용되는 네이밍 컨벤션은 아래와 같이 4가지가 있다. 123456789101112// 카멜 케이스 (camelCase)var firstName;// 스네이크 케이스 (snke_case)var first_name;// 파스칼 케이스 (PascalCase)var FirstName;// 헝가리언 케이스 (typehungarianCase)var strFirstName; // type + identifiervar $elem = $('.myClass') // jQuery 4. 데이터 타입이란 무엇인가? 왜 필요한가?컴퓨터는 한번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(byte 수)를 알아야한다. 숫자의 경우 8byte 단위로 읽어들이지 않으면 값이 훼손된다. 메모리 셀의 크기는 타입값이 할당되어 있어 자바스크립트 엔진이 타입을 인식하여 메모리 셀의 개수만큼 읽어 들인다. 데이터 타입이 필요한 이유 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 4.1. 값값(value)은 더 이상 평가할 수 없는 하나의 표현식이다. 12// 10 + 20은 표현식이다. 이 표현식은 평가되어 30이라는 값을 만든다.10 + 20 이 표현식은 자바스크립트 엔진에 의해 평가(evaluation)되어 30이라는 새로운 값을 생성한다. 새롭게 생성된 값 30은 더 이상 평가할 수 없다. 다시말해, 30을 평가하면 언제나 30이다. 값은 데이터 타입을 갖으며 메모리에 2진수, 즉 비트(bit)의 나열로 저장된다. 즉, 값에는 종류가 있다. 표현식 10 + 20 이 평가되어 생성한 값 30의 데이터 타입은 숫자 타입이다. 변수는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 12// 변수에는 표현식 10 + 20이 평가되어 생성한 값 30이 할당된다.var sum = 10 + 20; 변수 sum에 할당되는 것은 표현식이 아니라 표현식이 평가되어 생성한 값 30이다. 4.2. 값의 생성값은 다양한 방법(표현식)으로 생성할 수 있다. 가장 기본적인 방법은 리터럴 표기법을 사용하는 것이다. 5. 리터럴리터럴(literal)은 소스코드 안에서 직접 만들어 낸 고정된 값 자체를 말한다. 리터럴은 리터럴 표기법(literal notation)으로 생성한다. 5.1. 리터럴 표기법리터럴 표기법(literal notation)은 리터럴을 생성하는 방법이다. 리터럴 표기법은 값을 생성하는 가장 기본적인 방법이라고 할 수 있다. 자바스크립트 엔진은 리터럴 표기법으로 작성된 코드를 만나면, 코드가 실행되는 시점(런타임, runtime)에 리터럴을 해석하고 값을 생성한다. 123456789101112131415161718192021222324252627282930313233343536// 정수 리터럴1000// 부동 소숫점 리터럴10.5// 2진수 리터럴(0b로 시작)0b01000001// 8진수 리터럴(ES6에서 도입, 0o로 시작)0o101// 16진수 리터럴(ES6에서 도입, 0x로 시작)0x41// 문자열 리터럴'Hello'\"World\"// 불리언 리터럴truefalse//null 리터럴null// undefined 리터럴undefined// 객체 리터럴{name: 'Lee', gender: 'male'}// 배열 리터럴[1, 2, 3]// 함수 리터럴function(){}// 정규표현식 리터럴/ab+c 위 예제의 리터럴들은 표기법만 다를 뿐 메모리에는 동일한 2진수로 저장된다. 리터럴 표기법은 값을 생성하는 방법이다. 숫자 값을 생성하고 싶으면 개발자는 숫자 리터럴 표기법을 사용해 숫자 값의 생성을 자바 스크립트 엔진에게 요청한다. 자바스크립트 엔진은 숫자 리터럴을 해석하여 숫자 값을 생성하라는 개발자의 요청에 응답한다. 5.2. 값과 리터럴의 관계1var score = 100; 우변의 100은 리터럴인 동시에 값이다. 1var score = 50 + 50; 우변은 리터럴 표기법으로 두개의 리터럴 50을 만들고 + 연산자를 사용해 합산하고, 새로운 값을 생성한다. 이처럼 프로그램 내에서 값을 생성하는 문을 표현식(expression)이라 한다. 이처럼 기터럴 표기법은 값을 생성하는 가장 기본적인 방법이고, 이를 통해 생성된 리터럴은 값의 최소 단위이다. 리터럴은 그 자체로 값이 될 수 있지만 모든 값이 리터럴인 것은 아니다. 6. 표현식값은 다양한 표현식으로 생성할 수 있다. 표현식은 리터럴, 식별자(변수명, 함수명 등), 연산자, 함수 호출 등의 조합을 말한다. 표현식은 평가되어 하나의 값을 만든다. 즉, 표현식은 하나의 값으로 평가될 수 있는 문(statement)이다. 1234567891011121314151617// 리터럴 표현식10'hello'// 식별자 표현식sumperson.namearr[1]// 연산자 표현식10 + 20sum = 10sum !== 10// 함수/메소드 호출 표현식square()person.getName() 위 예제와 같이 가양한 표현식이 있지만 하나의 값으로 평가된다는 점에서 동일하다. 7. 데이터 타입의 분류자바스크립트의 모든 값은 원시타입(primitive type)과 객체 타입(object/reference type)으로 분류할 수 있다. 원시 타입(primitive type) 숫자(number) 타입 : 숫자(정수, 실수) 문자열(string) 타입 : 문자열 불리언(boolean) 타입 : 논리적 참과 거짓 undefined 타입 : 선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값 null 타입 : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 Symbol 타입 : ES6에서 새롭게 추가된 7번째 타입 객체 타입(object / reference type) : 객체, 함수, 배열 등 예를 들어 숫자 타입의 값 1과 문자열 타입의 값은 '1'은 비슷하게 보이지만 전혀 다른 값이다. 확보해야 할 메모리 공간의 크기도 다르고 메모리에 저장되는 2진수도 다르며 읽어 들여 해석하는 방식도 다르다. 개발자는 명확한 의도를 가지고 타입을 구별하여 값을 만들 것이고 자바스크립트 엔진은 타입을 구별하여 값을 취급할 것이다. 7.1. 숫자 타입c나 java의 경우, 정수와 실수를 구분하여 다양한 숫자 타입으로 구분하지만, 자바스크립트는 독특하게 모든 수를 실수로 처리하며 정수만을 표현하기 위한 데이터 타입이 없다. 7.2. 문자열 타입문자열은 작은 따옴표'', 큰 따옴표&quot;&quot;, 백틱 ``` ` 안에 텍스트를 넣어 생성한다.","link":"/2019/04/30/til-20190430/"},{"title":"정리중","text":"1. 중간 개념정리 1. Data type자바스크립트의 데이터타입은 원시타입과 객체타입으로 나눌 수 있습니다. 원시타입은 immutable value로 변경 불가능한 값이다. 여기서 변경 불가능한 값이란 변수가 가리키는 메모리공간의 값을 바꾸지 못하기 떄문에 재할당을 통해 새로운 메모리공간을 할당하기 전까지 변수에 저장된 값을 변경할 수 없다. 여기서 원시값을 저장할 때는 pass by value로 전달한다. 예로 a = 'abc', a[2] = 3 이 불가능 하다. 원시타입은 Number, String, Boolean, null, undefined, Symbol로 나눌 수 있다. 자바스크립트에서 숫자는 double로 처리되어 8byte의 메모리공간 무조건으로 차지한다. Number의 특별한 값으로는 infinity, -infinity, NaN 이있다. 자바스크립트에서 String은 유니코드문자를 사용해 문자하나당 2byte의 메모리 공간을 차지한다. 문자의 집합을 문자열이라 하고 문자열은 문자의 갯수만큼 동적으로 메모리공간을 차지한다. 문자열을 표현할 수 있는 방법은 작은따옴표, 큰따옴표, 백틱으로 표현할 수 있다. 보통 작은 따옴표를 사용한다. Template Literal 은 백틱을 사용한 표기법으로, 스트링인터폴래이션을 사용할 수 있다. Boolean값은 true, false로 나뉜다. 보통 제어문과 조건문에 사용된다. null은 명시적으로 아무것도 없다는 것을 의미한다. undefined는 자바스크립만의 특별한 데이터 타입으로 변수선언시 암묵적으로 자바스크립트가 언디파인드로 초기화 해준다. 호이스팅 Symbol은 안배웠다. 객체타입은 pass by reference 값 자체를 복사해서 메모리에 저장하는 것이 아닌 메모리주소를 저장한다. LiteralExpression표현식은 리터럴표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식 등으로 나누어 볼 수 있지만 결국 평가되어 하나의 값을 만든다. 즉 표현식은 하나의 값으로 평가될 수 있는 문이다. 문은 1개 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령이다. 자바스크립트의 문들의 집합이다. 문은 선언문, 표현식 문, 조건문, 반복문 등으로 구분할 수 있다. 12345678910111213141516// 리터럴 표현식10let sum = 100;// 식별자 표현식sum // 100// 연산자 표현식10 + 20 // 30 function add(x, y) { return x + y;}// 함수/메소드 호출 표현식add(1, 2); // 3 문은 표현식인 문과 표현식이 아닌 문으로 구분할 수 있다. 표현식인 문은 값으로 평가될 수 있는 문이며 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 표현식의 역할은 값을 생성하는 것이고, 문의 역할은 표현식으로 생성한 값을 사용해 자스크립트 엔진에게 명령을 내리는 것이다. Primitive type vs. Object typeFunction Definition함수는 정의가 있으면 호출이 있어야한다. 함수를 정의하는 방법에는 함수 선언문, 함수 표현식, 생성자함수, 화살표 함수가 있다. 123456789101112131415// 함수 선언문function add(x, y) { return x + y;}// 함수 표현식let add = function (x, y) { return x + y;}// 생성자 함수let add = new Function('x', 'y', 'return x + y');// 화살표 함수let add = (x, y) =&gt; x + y; 함수 선언문(Function Declaration)함수 선언문(Function Declaration)은 함수 리터럴 표기법과 형태가 동일하지만 함수명을 생략할 수 없다. 여기서 함수명은 함수 몸체 외부에서 참조할 수 없는 식별자이다. 하지만 함수호출을 할 때 우리는 함수 몸체 외부에서 함수명으로 호출할 수 있다. 이 이유는 자바스크립트 엔진은 함수명과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다. 이처럼 함수 선언문으로 생성한 함수는 결국에는 함수표현식과 비슷하게 동작한다. 하지만 결정적인 차이는 함수 호이스팅이 발생해 함수 선언문 위에서 함수를 호출해도 호출이 가능하다. 함수 표현식자바스크립트의 함수는 객체이다. 자바스크립트의 객체는 값처럼 변수에 할당 할 수도 있고 프로퍼티의 값이 될 수도 이스며 배열의 요소가 될 수도 있다. 이러한 객체를 일급 객체라 한다. 자바스크립트의 함수는 일급 객체이다. 함수는 일급 객체이므로 함수 리터럴로 생성한 삼수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라한다. 함수 표현식의 함수 리터럴은 함수명을 생략하는 것이 일반적이다. 함수표현식은 변수호이스팅이 일어난다. Function 생성자 함수생성자함수 방식으로 생성한 함수는 렉시컬 스코프를 만들지 않고 전역 함수인 것처럼 스코프를 생성하고, 클로저도 생성하지 않기 때문에 사용하지 않는다. 화살표 함수화살표 함수는 항상 익명 함수로 정의한다. 화살표함수에 없는것은 프로토타입과 아규먼츠객체가 없다. 모든 함수를 화살표함수로 정의하는 것은 아니다. 콜백함수 Scope변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결전된다. 이 범위를 스코프라 한다. 스코프는 전역스코프와 지역스코프로 나누어지는데 전역스코프는 코드어디에서든 참조가 가능하고 지역스코프는 자신의 지역 스코프와 하위지역 스코프에서 참조가 가능하다. 여기서 지역스코프는 각기 다른 레벨 스코프를 가지고 있는데 함수레벨 스코프와 블록레벨 스코프로 나뉘어 진다. 함수레벨스코프를 이해하기 위해서는 var키워드를 이해해야합니다. var 키워드는 반복문이나 조건문의 블록안에서 선언돼도 지역스코프를 갖지 못하는데 함수 블록 내부에서는 지역스코프를 가질 수 있다. 이를 함수레벨 스코프라하고 var키워드의 문제점을 보완하기 위해서 let 과 const가 나왔는데 이는 함수블록뿐 아니라 모든 블록문 안에서 지역스코프를 가질수있다. 이를 블록레벨스코프라 하낟. Lexical Scope함수의 상위스코프를 결정하는 방법에는 2가지가 있다. 함수를 어디서 호출했는지에 따라 상위 스코프를 결정한다. 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다. 여기서 1번은 동적스코프라 하고 2번은 렉시컬스코프 또는 정적스코프라 한다. 12345678910111213var x = 1;function foo() { var x = 10; bar();}function bar() { console.log(x);}foo(); // ?bar(); // ? 전역 변수의 문제점암묵적 결합전역 변수를 사용하는 의도는 코드 어디에서든지 전역 변수를 사용하겠다는 의미다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것으로 변슈의 유효 범위가 크면 클 수록 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다. 긴 생명 주기전역 변수는 브라우저가 꺼지기 전까지 죽지않는다. 이는 생명주기가 길다는걸 알려준다. 메모리의 리소스를 오랜 기간 소비하고, var키워드는 중복선언이 가능해 생명주기가 긴 전역변수는 변수명이 중복될 가능성이커 의도치 않은 재할당이 이루어 질 수 있다. 스코프체인상에서 종점에 존재var키워드로 선언한 전역변수는 window의 프로퍼티로 존재한다., 즉 스코프 체인의 종점에 존재한다는 말과 동일하다. 변수를 참조할때 스코프체인의 종점까지 검색행야해서 속도가 느릴 수 있다. 네임 스페이스 오염파일이 분리되어 있다하여도 하나의 전역 스코플를 공유해, 다른 파일에 동일한 변수명이 존재하면 예상치 못한 결과를 가져올 수 있다. var 키워드로 선언한 변수의 문제점변수 중복 선언 허용var키워드를 사용한 변수를 중복 선언할때 자바스크립트 엔진은 var키워드가 없는 것처럼 동작해 재할당을 하게된다. 블록레벨 스코프를 지원하지 않는다.변수 호이스팅var키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다. 이러한 문제를 해결하기 위해 let과 const가 등작했다. Constructor Functionnew 를 사용해 생성한 함수를 생성자함수라한다. 같은 구조의 객체를 여러개 만들수있다. thisthis는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다. 여기서 this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다. this가 바인딩되는 시점은 함수호출 방식에 따라 결정된다. 함수 호출 방식에는 일반함수호출, 메소드호출, 생성자함수호출, apply / call / bind 메소드에 의한 간접 호출 이 있다. 12345678910111213141516171819202122232425262728// this에 바인딩될 객체는 함수 호출 방식에 따라 동적으로 결정된다.const foo = function () { console.dir(this);};// 1. 일반 함수 호출// foo 함수를 일반적인 방식으로 호출// this는 전역 객체 window를 가리킨다.foo(); // window// 2. 메소드 호출// foo 함수를 프로퍼티의 값으로 할당하여 호출// this는 메소드를 호출한 객체 obj를 가리킨다.const obj = { foo };obj.foo(); // obj// 3. 생성자 함수 호출// foo 함수를 new 연산자와 함께 생성자 함수로 호출// this는 생성자 함수가 생성할 인스턴스 instance를 가리킨다.const instance = new foo(); // instance// 4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출// this는 인수에 의해 결정된다.const bar = { name: 'bar' };foo.call(bar); // barfoo.apply(bar); // barfoo.bind(bar)(); // bar DOM 브라우저 동작 Event Delegation## Event Capturing vs. Event Bubbling## Class## super## Prototype## Promise## 동기식 처리 모델 vs. 비동기식 처리 모델##","link":"/2019/06/02/til-20190602/"},{"title":"TypeScript","text":"1. TypeScript자바스크립트는 동적타입언어를 지원하여 값이 평가될 때 타입이 정해진다. 동적타입언어는 타입을 지정하지 않아도 값이 평가될 때 자바스크립트엔지에 의해 자동으로 타입이 정해지는 장점과 동시에 예상치 못한 타입이 들어와 잘못된 결과를 불러올 수 있는 단점이 있다. 자바스크립트(동적타입언어)의 단점을 극복하기 위해 나온 것이 타입스크립트(정적타입언어)이다. 타입스크립트는 자바스크립트의 상위확장(Superset)이다. 1.1. TypeScript의 장점먼저 자바스크립트를 보자. 123456789function sum(a, b) { return a + b;}// 개발자의 의도는 2개의 숫자를 받아 합계를 구하려는 것이다.sum(1, 3); // 4// 개발자의 의도와는 다르게 문자열을 넣어도 잘 동작한다.sum('a', 'b'); 타입스크립트는 이러한 문제를 타입 지정으로 사전에 차단할 수 있다. 123456789function sum(a: number, b: number) { return a + b;}// 개발자의 의도는 2개의 숫자를 받아 합계를 구하려는 것이다.sum(1, 3); // 4// 개발자의 의도와는 다르게 문자열을 넣어도 잘 동작한다.sum('a', 'b'); 2. TypeScript의 타입TypeScript의 타입은 EcmaScript의 타입을 유지한 상태로 추가적인 타입을 더 지원하고 있다. Type JS TS Description boolean O O true, false null O O 값이 없다는 것을 명시 undefined O O 값을 할당하지 않은 변수의 초기값 number O O 숫자(정수, 실수, Infinity, NaN) string O O 문자열 symbol O O 고유하고 수정 불가능한 데이터타입이며 주로 객체 프로퍼티들의 실별자로 사용 object O O 객체형 array O 배열 tuple O 고정된 요소수 만큼의 타입을 미리 선언후 배열을 표현 enum O 열거형, 숫자값 집합에 이름을 지정한 것이다. any O 타입 추론(type inference)을 할 수 없거나 타입 체크가 필요없는 변수에 사용. var 키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당 가능. void O 일반적으로 함수에서 반환값이 없을 경우 사용한다. never O 결코 발생하지 않는 값. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// numberlet decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744;// stringlet color: string = \"blue\";color = 'red';let myName: string = `Lee`; // ES6 템플릿 문자열let greeting: string = `Hello, my name is ${ myName }.`; // ES6 템플릿 대입문// booleanlet a: boolean = false;// nulllet n: null = null;// undefinedlet u: undefined = undefined;// objectconst obj: object = {};// arraylet list1: any[] = [1, 'two', true];let list2: number[] = [1, 2, 3];let list3: Array&lt;number&gt; = [1, 2, 3]; // 제네릭 배열 타입// tuple : 고정된 요소수 만큼의 타입을 미리 선언후 배열을 표현let tuple: [string, number];tuple = ['hello', 10]; // OKtuple = [10, 'hello']; // Errortuple = ['hello', 10, 'world', 100]; // Errortuple.push(true); // Error// enum : 열거형은 숫자값 집합에 이름을 지정한 것이다.enum Color1 {Red, Green, Blue};let c1: Color1 = Color1.Green;console.log(c1); // 1enum Color2 {Red = 1, Green, Blue};let c2: Color2 = Color2.Green;console.log(c2); // 2enum Color3 {Red = 1, Green = 2, Blue = 4};let c3: Color3 = Color3.Blue;console.log(c3); // 4/*any: 타입 추론(type inference)할 수 없거나 타입 체크가 필요 없는 변수에 사용한다.var 키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당할 수 있다.*/let notSure: any = 4;notSure = 'maybe a string instead';notSure = false; // okay, definitely a boolean// void : 일반적으로 함수에서 반환값이 없을 경우 사용한다.function warnUser(): void { console.log(\"This is my warning message\");}// never : 결코 발생하지 않는 값function infiniteLoop(): never { while (true) {}}function error(message: string): never { throw new Error(message);} 3. 타입 추론타입 선언을 생략하고 값을 할당하면 동적으로 타입이 결저된다. 이를 타입 추론(Type Inference)이라 한다. 1234567let a = 123; // numberlet b = 123;b = 2;let c = 123;c = 'asdf' // error: Type '\"asdf\"' is not assignable to type 'number'. 타입추론으로 타입이 처음 선언되면 후에 재할당을 할 때 같은 타입만 할당이 가능하다. 4. 클래스자바스크립트에서 기본적인 형태의 클래스를 선언하면 정상적으로 동작한다. 1234567891011class Person { constructor(name) { this.name = name; } sayHi() { console.log(`안녕 나는 ${this.name}이야`); }}const sungjin = new Person('성진');sungjin.sayHi(); // 안녕 나는 성진이야 하지만 이 문을 그대로 타입스크립트에서 쓰면 오류가 일어난다. 타입스크립트는 클스 몸체에 클래스 프로퍼티를 사전에 선언하여야 한다. 12345678910111213class Person { name: string; constructor(name: string) { this.name = name; } sayHi() { console.log(`안녕 나는 ${this.name}이야`); }}const sungjin = new Person('성진');sungjin.sayHi(); // 안녕 나는 성진이야 4.1. 접근 제한자TypeScript의 클래스는 클래스 기반 객체 지향언어가 지원하는 접근 제한자를 지원하며 의미 또한 기본적으로 동일하다. 단 접근 제한자를 명시하지 않았을 경우 클래스 기반 언어는 암묵적으로 protected로 지정되지만, TypeScript의 경우 암묵적으로 public이 선언된다. 접근 가능성 public protected private 클래스 내부 O O O 자식 클래스 내부 O O X 클래스 인스턴스 O X X 1234567891011121314151617181920212223242526272829303132333435363738class Person { public name: string; protected age: number; private student: boolean; constructor(name: string, age: number, student: boolean) { this.name = name; this.age = age; this.student = student; } sayHi() { console.log(`${this.name}, ${this.age}, ${this.student}`); }}const me = new Person('성진', 25, false);// public은 클래스 인스턴스를 통해 클래스 외부에서 참조가 가능하다.console.log(me.name);// protected는 클래스 인스턴스를 통해 클래스 외부에서 참조가 불가하다.console.log(me.age);// private은 클래스 인스턴스를 통해 클래스 외부에서 참조가 불가하다.console.log(me.student);class man extends Person { constructor(name: string, age: number, student: boolean) { super(name, age, student); // public은 자식 클래스 내부에서 참조가 가능하다. console.log(this.name); // protected는 자식 클래스 내부에서 참조가 가능하다. console.log(this.age); // private은 자식 클래스 내부에서 참조가 불가하다. console.log(this.student); }} 5. 인터페이스인터페이스는 타입 체크를 위해 사용되며 변수, 함수, 클래스에 사용할 수 있다. 인터페이스는 여러가지 타입을 갖는 프로퍼티를 새로운 타입으로 정의하는 것이다. 5.1. 변수와 인터페이스인터페이스는 사전에 변수의 타입을 지정하여 다른 변수의 타입으로 사용할 수 있다. 12345678910111213141516// 인터페이스를 정의한다.interface Person { name: string; age: number;}// 변수 me의 타입으로 Person을 지정해준다.let me: Person;// 변수 me는 Person 인터페이스를 준수하여야 한다.me = { name: '최성진', age: 25 };// 배열에 해당 인터페이스를 규정한다.let you: Person[];you = [{ name: '이규하', age: 29 }]; 6. 클래스와 인터페이스클래스 선언문 + implements 뒤에 인터페이스를 선언하면 해당 클래스는 지정된 인터페이스를 반드시 구현해야 한다. 이는 인터페이스를 구현하는 클래스의 일관성을 유지할 수 있는 장점을 갖는다. 123456789101112131415// 인터페이스의 정의interface IPerson { name: string; age: number;}// Todo 클래스는 ITodo 인터페이스를 구현하여야 한다.class man implements IPerson { constructor ( public name: string, public age: number, ) { }}const todo = new Todo('sungjin', 25); 6.1. 덕 타이핑 (Duck Typing)인터페이스를 구현하는 것은 타입 체크를 하기 위한 방법만 아니라 ‘당신은 이걸 꼭 써야해’라고 명시해주는 역할도 할 수 있다. 12345678910111213141516171819202122interface IDuck { // 1 quack(): void;}class MallardDuck implements IDuck { // 3 quack() { console.log('Quack!'); }}class RedheadDuck { // 4 quack() { console.log('q~uack!'); }}function makeNoise(duck: IDuck): void { // 2 duck.quack();}makeNoise(new MallardDuck()); // Quack!makeNoise(new RedheadDuck()); // q~uack! // 5 위에서 모든 덕들은 소리를 가지고 있지만 각자 다른 소리를 내기 때문에 ‘너네는 소리 메서드를 넣어야하지만 내가 다 할 수 없으니 덕 메서드는 꼭 넣어라’라고 명시 해주는 역할도 하고있다.","link":"/2019/06/12/til-20190612/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Codewars","slug":"Codewars","link":"/tags/Codewars/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"JavaSript","slug":"JavaSript","link":"/tags/JavaSript/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"TodoList","slug":"TodoList","link":"/tags/TodoList/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"웹 사이트","slug":"웹-사이트","link":"/tags/웹-사이트/"},{"name":"웹 표준","slug":"웹-표준","link":"/tags/웹-표준/"},{"name":"웹 접근성","slug":"웹-접근성","link":"/tags/웹-접근성/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"linear-gradient","slug":"linear-gradient","link":"/tags/linear-gradient/"},{"name":"white-space","slug":"white-space","link":"/tags/white-space/"},{"name":"가상요소 선택자","slug":"가상요소-선택자","link":"/tags/가상요소-선택자/"},{"name":"애니메이션","slug":"애니메이션","link":"/tags/애니메이션/"},{"name":"Form","slug":"Form","link":"/tags/Form/"},{"name":"Flex","slug":"Flex","link":"/tags/Flex/"},{"name":"컴퓨터공학","slug":"컴퓨터공학","link":"/tags/컴퓨터공학/"},{"name":"Bubble Sort","slug":"Bubble-Sort","link":"/tags/Bubble-Sort/"},{"name":"Selection Sort","slug":"Selection-Sort","link":"/tags/Selection-Sort/"},{"name":"Insertion Sort","slug":"Insertion-Sort","link":"/tags/Insertion-Sort/"},{"name":"Merge Sort","slug":"Merge-Sort","link":"/tags/Merge-Sort/"},{"name":"시작","slug":"시작","link":"/tags/시작/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"웹 브라우저","slug":"웹-브라우저","link":"/tags/웹-브라우저/"},{"name":"변수","slug":"변수","link":"/tags/변수/"},{"name":"데이터 타입","slug":"데이터-타입","link":"/tags/데이터-타입/"},{"name":"예습","slug":"예습","link":"/tags/예습/"},{"name":"러버덕","slug":"러버덕","link":"/tags/러버덕/"},{"name":"기초 알고리즘","slug":"기초-알고리즘","link":"/tags/기초-알고리즘/"},{"name":"제어문","slug":"제어문","link":"/tags/제어문/"},{"name":"반복문","slug":"반복문","link":"/tags/반복문/"},{"name":"조건문","slug":"조건문","link":"/tags/조건문/"},{"name":"객체 리터럴","slug":"객체-리터럴","link":"/tags/객체-리터럴/"},{"name":"별찍기","slug":"별찍기","link":"/tags/별찍기/"},{"name":"변수의 생명주기","slug":"변수의-생명주기","link":"/tags/변수의-생명주기/"},{"name":"키워드","slug":"키워드","link":"/tags/키워드/"},{"name":"생성자 함수","slug":"생성자-함수","link":"/tags/생성자-함수/"},{"name":"Math.PI","slug":"Math-PI","link":"/tags/Math-PI/"},{"name":"Math.random","slug":"Math-random","link":"/tags/Math-random/"},{"name":"Math.ceil","slug":"Math-ceil","link":"/tags/Math-ceil/"},{"name":"toString","slug":"toString","link":"/tags/toString/"},{"name":"String.substring","slug":"String-substring","link":"/tags/String-substring/"},{"name":"String.replace","slug":"String-replace","link":"/tags/String-replace/"},{"name":"String.indexOf","slug":"String-indexOf","link":"/tags/String-indexOf/"},{"name":"고차함수","slug":"고차함수","link":"/tags/고차함수/"},{"name":"연습문제","slug":"연습문제","link":"/tags/연습문제/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"복습","slug":"복습","link":"/tags/복습/"},{"name":"원시 값","slug":"원시-값","link":"/tags/원시-값/"},{"name":"객체","slug":"객체","link":"/tags/객체/"},{"name":"함수","slug":"함수","link":"/tags/함수/"},{"name":"스코프","slug":"스코프","link":"/tags/스코프/"},{"name":"프로토타입","slug":"프로토타입","link":"/tags/프로토타입/"},{"name":"클래스","slug":"클래스","link":"/tags/클래스/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"모듈","slug":"모듈","link":"/tags/모듈/"},{"name":"실행 컨텍스트","slug":"실행-컨텍스트","link":"/tags/실행-컨텍스트/"},{"name":"SPA","slug":"SPA","link":"/tags/SPA/"},{"name":"개념정리","slug":"개념정리","link":"/tags/개념정리/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Assignment","slug":"Assignment","link":"/categories/Assignment/"},{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"HTML & CSS","slug":"TIL/HTML-CSS","link":"/categories/TIL/HTML-CSS/"},{"name":"컴퓨터공학","slug":"TIL/컴퓨터공학","link":"/categories/TIL/컴퓨터공학/"},{"name":"JavaScript","slug":"TIL/JavaScript","link":"/categories/TIL/JavaScript/"}]}