{"pages":[],"posts":[{"title":"algorithm_codewars_directions-reduction","text":"","link":"/2019/06/07/algorithm-codewars-directions-reduction/"},{"title":"[Codewars] Consecutive strings","text":"(6kyu) Consecutive strings 설명 : 배열의 원소로 임의의 문자열과, 정수 k 가 들어온다. 배열의 원소들을 k개씩 잘라 합치고, 길이를 비교해 제일 긴 값을 반환한다. 12345678910111213141516171819202122232425function longestConsec(strarr, k) { var len = strarr.length; var result = []; var comp; if(len == 0 || k &gt; len || k &lt;= 0){ return ''; } for(let i = 0; i &lt; k; i++){ result += strarr[i]; } for(let i = 0; i &lt; len-k+1; i++){ for(let j = 0; j &lt; k; j++){ comp += strarr[i+j]; } if(result.length &lt; comp.length){ result = comp; } comp = []; } return result;} 내가 생각한 핵심 : 문제를 풀기 전까지는 몰랐는데 풀면서 확인해보니 배열의 문자열을 comp에 더해주니까 하나의 문자열로 합쳐졌다. 이런 상황은 생각하고 풀지 않았는데 풀어보니 암묵적 형변환이 일어나서 오늘 배운 내용이 생각나면서 신기했다.","link":"/2019/05/07/algorithm-codewars-consecutive-strings/"},{"title":"algorithm_codewars_double_cola","text":"","link":"/2019/06/07/algorithm-codewars-double-cola/"},{"title":"algorithm_codewars_exes-and-ohs","text":"","link":"/2019/06/07/algorithm-codewars-exes-and-ohs/"},{"title":"algorithm_codewars_multiples-of-3-or-5","text":"","link":"/2019/06/07/algorithm-codewars-multiples-of-3-or-5/"},{"title":"algorithm_codewars_persistent-bugger","text":"","link":"/2019/06/07/algorithm-codewars-persistent-bugger/"},{"title":"algorithm_codewars_playing-with-digits","text":"","link":"/2019/06/07/algorithm-codewars-playing-with-digits/"},{"title":"algorithm_codewars_take_a_number","text":"","link":"/2019/06/07/algorithm-codewars-take-a-number/"},{"title":"algorithm_leetcode_longest-common-prefix","text":"","link":"/2019/06/07/algorithm-leetcode-longest-common-prefix/"},{"title":"algorithm_leetcode_reverse-integer","text":"","link":"/2019/06/07/algorithm-leetcode-reverse-integer/"},{"title":"algorithm_leetcode_two-sum","text":"","link":"/2019/06/07/algorithm-leetcode-two-sum/"},{"title":"웹 사이트의 구조, 웹 접근성과 웹 표준","text":"1. 웹사이트의 구조 HTML(Hyper Text Markup Language)구조를 잡는다. (건강한 신체) CSS(Casecade Style Sheets)html 요소들을 꾸민다. (화려한 스타일) Javascript정적인 페이지를 동적으로 변화시켜준다. (스마트한 두뇌) 2. 웹 접근성과 웹 표준2.1. 웹 표준(Web Standards) W3C (World Wide Consortium)에서 정의하는 기술 표준을 또는 규격을 말한다. 웹 표준의 궁극적인 목적은 웹사이트에 접속한 사용자가 어떠한 운영체제나 브라우저를 사용하더라도 동일한 결과를 보이게 하는 것이다. 2.1.1. 웹 표준이 되는 과정 Working Draft(WD) : 초안 Candidate Recommendation(CR) : 후보 권고안 Proposed Recommendation(PR) : 제안권고안 W3C Recommendation(REC) : 권고안 2.2. 웹 접근성(Web Accessibility)장애인, 고령자 등 모든 사용자가 어떠한 기술이나 환경에서도 전문적인 능력 없이 웹사이트에서 제공하는 모든 정보를 동등하게 접근하고 이해할 수 있는 권리입니다. 장애는 볼수없는것이 아니라 보는 방법이 다를뿐 (서울대 이상묵교수님) 2.2.1. 신체적인 접근성(장애) 시력장애, 청각장애, 지체장애, 뇌병변장애 그 외 신체적 장애 2.2.2. 환경에 대한 이해 다양한 Platform Cross Browsing SEO(Search Engine Optimization) 저사양 또는 저속회선 3. HTML(HyperText Markup Language)HTML은 웹 페이지 제작을 위한 마크업 언어다. 3.1. 의미론적 마크업(Sementic Markup)HTML 태그는 의미를 가진 태그와 의미를 가지지 않은 태그로 나뉘어져있다. 웹페이지에서 같은 모양으로 출력된다고 해도, 실제로 가지고 있는 의미는 서로 다를 수 있다. 예를 들어 태그를 안쓰고도 제목 모양의 스타일링을 할 수는 있지만 그것은 ‘표현’ 영역에 해당하고 내용-구조를 담당하는 HTML의 역할을 다 했다고 하기 어려운 것이다. 3.2. 검색엔진최적화(SEO, Search Engine Optimization)검색엔진최적화(Search Engine Optimization)란, 웹사이트의 HTML 코드에서 정보를 모아 검색 키워드에 맞는 적절한 웹사이트를 보여주기 위한 것이다. 따라서 HTML의 요소들을 가지고 해당 웹페이지의 내용을 파악하고 그것이 검색엔진에 노출될 수 있도록 하기 위해서 시멘틱한 마크업이 필요하다.","link":"/2019/04/01/til-20190401/"},{"title":"css의 상속, 겹침, 우선순위, layout","text":"1. CSS(Casecade Style Sheets)1.1. 가장 중요한 3가지 상속layout 프로퍼티는 상속받지 않고, decoration 프로퍼티만 상속받는다. 겹침가장 마지막에 선언된 스타일이 우선순위가 높다. 우선순위선택자 각각의 우선순위를 구별할 수 있어야한다. 선택자 점수 태그 (tag) 1점 클래스 (class) 10점 아이디 (id) 100점 1.2. Layout 1.2.1.display block view포트를 기준으로 한줄을 다 차지하여, 줄 바꿈이 일어나고 크기를 지정할 수 있다. inline 콘텐츠의 크기에 맞게 사이즈가 조절되어, 줄 바꿈이 일어나지 않고, 크기조절이 불가하다. inline-block 혼합된 형태로 크기조절이 가능하고, 줄 바꿈이 일어나지 않는다. flex 다른 속성들과 다르게 유연함을 가지고 있다. grid 세로 열과 가로 행의 테이블형식으로 만들어 위치를 마음대로 이동시킬 수 있다. 1234567.layout { display: block; display: inline; display: inline-block; display: flex; display: grid;} 1.2.2. position static 모든 태그의 기본 상태이고 왼쪽에서 오른쪽, 위에서 아래로 정렬된다. relative 선택된 요소를 기준으로 top, right, bottom, right를 사용하여 위치를 움직일 수 있다. absolute static 속성이 아닌 부모를 기준으로 top, right, bottom, right를 사용하여 움직일 수 있다. fixed 상단의 메뉴바에 많이 쓰이는 속성으로, 고정된 자리를 가진다. 123456.layout { position: static; position: relative; position: absolute; position: fixed;} 1.2.3. float left 일반적인 흐름에서 벗어나 공중에 붕 떠있는 형태로 왼쪽 정렬을 한다. right 일반적인 흐름에서 벗어나 공중에 붕 떠있는 형태로 오른쪽 정렬을 한다. 1234.layout { float: left; float: right;} 2. emmet모든 에디터에 제공되는 자동완성 기능이다.ex) ul.member&gt;li*5&gt;a[href=&quot;#&quot;] 123456789&lt;!-- ul.member&gt;li*5&gt;a[href=\"#\"] --&gt;&lt;ul class=\"member\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;","link":"/2019/04/02/til-20190402/"},{"title":"css프로퍼티, 애니메이션","text":"1. CSS 프로퍼티 1.1. linear-gradient() 배경 및 색깔에 그라데이션이 필요할 때 사용한다. linear-gradient 앞쪽에 색을 선언하면 그라데이션이 안먹을 경우 앞에 선언한 컬러가 적용됨 123box{ background: black linear-gradient(to bottom, white 0%, gray 50%, black 100%);} 1.2. white-space스페이스와 탭, 줄바꿈, 자동줄바꿈의 처리 방식을 정할 때 사용한다. normal 자동 줄바꿈 - O, 스페이스및 탭 - 병합 nowrap 자동 줄바꿈 - X, 스페이스및 탭 - 병합 pre 자동 줄바꿈 - X, 스페이스및 탭 - 기본 pre-wrap 자동 줄바꿈 - O, 스페이스및 탭 - 기본 pre-line 자동 줄바꿈 - O, 스페이스및 탭 - 병합 1.3. ::after ::before 다른 선택자의 뒤에 함께 쓰여 원하는 텍스트 및 스타일을 넣거나 지정할 때 사용한다. 가상요소 선택자를 쓸 경우 필수로 content 속성이 필요하다. 123box::after{ content: \"o\";} 2. CSS 애니메이션 2.1. @keyframes정해진 시간분할에 따라 %, from-to 단위로 애니메이션(animation)을 구현하기 위한 것이며 이를 위해 animation 속성 사용 후 keyframe 과 연결하여 애니메이션을 구현한다. 12345678910111213141516171819202122/* % */@keyframes percentage{ 0%{ opacity: 0; } 50%{ opacity: 1; } 100%{ opacity: 0.3; }}/* from-to */@keyframes from-to{ from{ height: 0; } to{ height: 100px; }} 2.2. animation-name어떤 keyframe을 연결할지 지정한다. 2.3. animation-duration애니메이션이 얼마 동안 구현 될지에 대한 시간을 지정한다. 2.4. animation-delay애니메이션을 즉시 재생하지 않고 지정한 시간 동안 지연 후 재생하도록 한다. 2.5. animation-fill-mode애니메이션의 시작/끝 상태를 제어한다. 2.6. animation-iteration-count애니메이션 반복 횟수를 지정한다.(infinite, 무한대) 2.7. animation-timing-function애니메이션이 재생될 때의 시간차에 대한 함수를 지정한다. 2.8. ease, linear, ease-in, ease-out, ease-in-out특정 곡선이 아닌 임의의 시간차를 필요로 할 경우에는 cubic-bezier 함수를 사용한다. 2.9. animation-direction 애니메이션이 어떤 형식으로 반복할지에 대한 반복형식을 지정한다. alternate로 지정하는 경우 from에서 to로 갔다가 다시 to에서 from으로 가도록 한다. animation-direction 속성이 제대로 동작하려면 animation-iteration-count 속성에 반복 횟수가 지정되어 있어야 한다. 2.10. animation-play-state 애니메이션의 재생 상태를 지정한다. paused 값을 사용해 애니메이션을 일시적으로 정지 시킬 수 있다. 1234567891011.box{ animation-name: from-to; animation-duration: 3.3s; animation-delay: 2s; animation-fill-mode: forwards; animation-iteration-count: infinite; animation-timing-function: linear; animation-direction: alternate; animation-play-state: running; height: auto;}","link":"/2019/04/03/til-20190403/"},{"title":"til_20190404","text":"","link":"/2019/06/07/til-20190404/"},{"title":"til_20190405","text":"","link":"/2019/06/07/til-20190405/"},{"title":"til_20190408","text":"","link":"/2019/06/07/til-20190408/"},{"title":"til_20190409","text":"","link":"/2019/06/07/til-20190409/"},{"title":"til_20190410","text":"","link":"/2019/06/07/til-20190410/"},{"title":"til_20190417","text":"","link":"/2019/06/07/til-20190417/"},{"title":"til_20190422","text":"","link":"/2019/06/07/til-20190422/"},{"title":"til_20190423","text":"","link":"/2019/06/07/til-20190423/"},{"title":"til_20190424","text":"","link":"/2019/06/07/til-20190424/"},{"title":"til_20190425","text":"","link":"/2019/06/07/til-20190425/"},{"title":"til_20190426","text":"","link":"/2019/06/07/til-20190426/"},{"title":"프론트엔드와 자바스크립트","text":"1. 프론트엔드 개발자가 웹 퍼블리셔 다른점서버와 관계가 밀접하고 동적으로 웹페이지를 만든다. 2. 웹 어플리케이션과 어플리케이션 2.1. 웹 어플리케이션 브라우져를 이용하여 접속하여, 별도의 프로그램이 필요하지 않다. 웹 브라우져로 구동이 되기 때문에, 웹 브라우져를 잘 알아야한다. 2.2. 어플리케이션 실행파일이 따로 존재해, 다운로드를 받아야한다. 웹 브라우져로 접속이 필요없다. 3. UI(user interface) 애플리케이션을 사용하는 사람(유저)이 애플리케이션과 소통하기 위한 창구(user interface)를 사용하기 좋게 구현한다.(커뮤니케이션) 상태 정보를 서버로 전송하기도 하고, 서버의 데이터를 가져와서 UI에 표시하기도 한다. 4. 초심가자 경험하는 어려움 책이나 수업의 내용이 무슨 말인지 하나도 모르겠다. 주변 개발자의 말을 알아 들을 수 없다. 배경 지식 : 기본적인 CS(컴퓨터공학)지식 + 개념(용어)에 대한 이해 어떻게 만들어야 할 지 감조차 오지 않는다. 문제 해결 능력 : 문제(해결과제)가 무엇인지 알아채는 능력 + Computational thinking(컴퓨터 입장에서 생각) + 알고리즘/자료구조 + 경험 *문제해결능력 = 해결 과제(문제/요구사항)의 명확한 이해 -&gt; 복잡함을 단순하게 분해 -&gt; 자료를 정하고 구분(modelling) -&gt; 순서에 맞게 행위 배열 초심자는 코딩보단, 전문용어를 배우는게 좋다. 4.1. 효율적인 프로그래밍 학습은 없다. 연습을 꾸준히 반복하는 만큼 성장한다. 라이브코딩 감상과 예제 단순 타이핑은 연습이 아니다. 자신의 능력을 살짝 넘어서는 도전을 지속적으로 시도하는 것이 연습니다. 시행차교(a.k.a.삽질)은 “무엇을 알고 무엇을 모르는지”를 알게하는 개발자의 벗이자 선생님이다. 무엇을 모르는지 알았다면 몰랐던 것을 알기위해 “시도하고 실패하는 의식적인 연습을 반복” 한다. 하지만 모르는 것이 너무 많다. 베이스가 되는 것부터 구체적인 목표를 수립하고 학습하고 작은 성취를 반복하자. 수박 겉핥기식 학습도 문제지만 본질에서 벗어난 학습도 문제다. 피드백에 겸손하고 적극적으로 반응하여 행동을 교정하라. 5. 프로그래밍이란? 순서에 맞게 위에서 아래로 실행된다. 5.1. 프로그래밍언어란? 프로그래밍을 하기위한 언어이다. 컴퓨터와 커뮤니케이션을 하기 위한 언어이다. 5.2. HTML &amp; CSS 선언형 프로그래밍 언어이다. 미리 만들어 놓은 태그와 속성을 사용한다. 6. 코딩을 잘한다? 예전 : 메모리가 비싸서 가장 덜 쓰고 성늘을 높히는 것 현재 : 사람이 읽을때 쉽게 읽을 수 있게한다.(가독성을 좋게한다) 7. 개발자와 컴퓨터가 공통으로 알고 있는 언어javascript는 엔진을 통해 컴퓨터에게 언어를 습득하게 한다. 7.1. JavaScript7.1.1. ecmascript(core javascript) + api(환경에 따라 다름) 7.1.2. interpreter language 한줄 한줄 동시통역처럼 컴퓨터에게 바이트 코드를 만들어준다. 예전에는 느렸지만 google의 v8엔진 도입으로 속도가 비약적으로 빨라졌다. 웹브라우저에서 돌아가는 유일한 언어이다.(HTML &amp; CSS 도 같이) 7.1.3. JavaScript를 실행할 수 있는 환경 브라우저 ecmascript + web api(브라우저가 제공한다) 클라이언트 사이드에서 사용한다. node.js 환경 ecmascript + node.js api 서버 사이드에서 사용한다. v8 엔진을 내장한다. 파일 컨트롤이 가능하며, 서버에서 직접 관리가 가능하다. 오늘 알아야 할 것 ecmascript와 javascript가 무엇인가? wep api가 무엇인가?","link":"/2019/04/29/til-20190429/"},{"title":"예습","text":"1. 자바스크립트 실행 환경 브라우저와 node.js는 자바스크립트를 해석하고 실행할 수 있는 v8엔진을 내장하고 있다. 기본적으로 브라우저에서 동작하는 코드는 node.js 환경에서도 동작한다. 하지만 브라우저와 node.js의 존재 목적은 다르다. 1.1. 브라우저 HTML, CSS, JavaScript를 실행하여 웹페이지를 화면에 렌더링하는 것이 주된 목적이다. ECMAScript(core javascript)를 실행할 수 있다. 브라우저가 제공하는 Wep API를 사용할 수 있다. 따라서, 사용자의 컴퓨터에 파일 생성이 불가하다. 1.2. node.js 서버 개발 환경을 제공하는 것이 주된 목적이다. ECMAScript(core javascript)를 실행할 수 있다. node.js가 제공하는 고유의 API를 사용할 수 있다. 2. 웹 브라우저는 어떻게 동작하는가?구글의 v8엔진의 등장으로 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되는 범용 개발 언어가 되었다. 하지만 가장 많이 사용되는 분야는 역시 웹 브라우저 환경에서 동작하는 웹 페이지/애플리케이션이다 브라우저의 핵심 기능은 사용자가 참조하고자 하는 웹 페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것이다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(parsing)되어 DOM, CSSOM 트리로 변환되고 Render트리로 결합된다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 표시한다. 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 제어 권한을 넘겨 받은 자바스크립트 엔진은 모든 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨 브라우저가 중지 됐던 시점부터 DOM 생성을 재개한다. 이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, JavaScript 를 처리한다. 이것은 script 태그의 위치에 따라 블로킹이 발생하여 DOM 생성이 지연될 수 있다는 것을 의미한다. 2.1. node.js구글 chrome v8 자바스크립트 엔진으로 빌드된 자바스크립트 런타인 환경(Runtime Environment)이다. 간단히 말하면 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바 스크립트 실행 환경이 node.js 이다. 3. 변수란 무엇인가? 왜 필요한가?10+20 을 예로 들어보자. 숫자 값 10과 20은 메모리 상의 임의의 위치에 기억되고, 연산 결과로 생성된 숫자 값 30도 메모리 상의 임의의 위치에 저장된다. 성공적으로 연산이 끝났고 연산 결과도 메모리에 저장됐지만 연산하여 만들어낸 숫자 값30을 재사용할 수 없다는 문제가 있다. 만약 결과 값 30을 재사용하고 싶다면 저장된 메모리 공간의 주소에 직접 접근하는 것 이외에는 방법이 없다. 하지만 메모리 주소로 메모리에 직접 접근하는 것은 시스템을 멈추게 할 수도 있는 치명적 오류를 생산할 가능성이 높은 매우 위험한 일이다. 따라서 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다. 기억하고 싶은 데이터를 메모리에 저장하고, 저장된 데이터를 읽어 들여 재사용하기 위해 프로그래밍 언어는 변수를 제공한다. 변수(variable)는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 간단히 말하자면 변수는 값을 저장하고 참조하는 메커니즘으로 값에 이름을 붙인 것이다. 번수를 통해 개발자는 메모리 주소를 직접 다루지 않아아도 값을 저장하거나 참조할 수 있고 값을 변경할 수도 있다. 변수에 값을 저장하는 것을 할당(assignment 대입, 저장)이라 하고, 변수에 저장된 값을 읽어 들이는 것을 참조(reference)라고 한다. 변수는 사람의 언어로 기술한 변수명을 통해 저장된 값의 의미를 명확히 할 수 있다. 따라서 코드의 가독성을 높여주는 부수적이 효과도 얻을 수 있다. 3.1. 변수 선언변수 선언(variable declaration)이란 변수명(식별자)을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다. 변수를 선언할 때는 var, let, const 키워드를 사용한다. 변수를 선언하고 변수 값을 할당하지 않으면 자바스크립트 엔진에 의해 undefined 라는 값이 암묵적으로 할당되어 초기화된다. 이것은 자바스크립트의 독특한 특징이다. 자바스크립트 엔진은 변수 선언을 아래의 2단계를 거쳐 수행한다. 선언 단계(Declaration phase) : 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 실행 컨텍스트 : 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 초기화 단계(Initialization phase) : 값을 저장하기 위해 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다. var score;는 선언단계를 통해 변수명 score를 등록하고, 초기화 단계를 통해 변수 score에 암묵적으로 undefined를 할당하여 초기화한다. 만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값(Gavage value)이라 한다. 따라서 메모리 공간을 확보한 다음 값을 할당하지 않은 상태에서 곧바로 변ㄷ수값을 참조하면 쓰레기 값이 나올 수 있다. ReferenceError 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 참조 에러다.(변수를 사용하려면 반드시 선언이 필요하다.) 3.2. 변수 선언의 실행 시점과 변수 호이스팅12console.log(score);var score; 위의 예제를 살펴보면 console.log(score) 가 먼저 실행된다. 하지만 console.log(score) 가 실행되는 시점에는 아직 변수 score의 선언이 실행되지 않았으므로 참조 에러(ReferenceError)가 발생할 것처럼 보인다. 하지만 참조 에러는 발생하지 않고 undefined가 출력된다. 변수 선언은 소스 코드가 순차적으로 한줄씩 실행되는 시점(런타임, run-time)이 아니라 그 이전(파싱 타임, parsing-time)에 먼저 실행된다. 즉 자바스크립트 엔진은 소스 코드를 한줄씩 순차적으로 실행하기 이전에 먼저 소스 코드 전체를 평가한다. 이때 모든 선언문을 찾아내어 식별자를 등록하고 초기화한다. 그후, 선언문을 제외한 소스 코드를 한줄씩 순차적으로 실행한다. 런타임 : 소스 코드가 순차적으로 한줄씩 실행되는 시점 파싱타임 : 소스 코드가 실행되기 이전 위 예제와 같이 변수선언이 되기 이전에 console.log(score)가 실행되므로 참조에러가 발생해야 한다. 하지만 undefined가 출력된다. 이는 변수 선언이 다른 코드가 실행되기 이전에 먼저 실행된다는 증거이다. 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)이라 한다. 3.3. 값의 할당변수에 값을 할당(assignment 대입, 저장)할 때는 할당 연산자(=)를 사용한다. 할당 연산자는 우변의 값을 좌변으 변수에 할당한다. 변수 선언은 다른코드가 실행되기 이전, 즉 파싱타임에 먼저 실행되지만 값의 할당은 코드가 순차적으로 실행되는 시점인 런타임에 실행된다. 즉 자바스크립트 엔진은 변수의 선언과 값의 할당을 분리해서 각각 실행한다. 3.4. 값의 재할당var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수가 저장하고 있는 값을 버리고 새로운 값을 저장하는 것이다. 변수에 값을 재할당하면 변수 score는 이전 값 80에서 재할당 값 90으로 변경된다. 처음 할당됐던 공간을 지우는게 아니라 새로운 공간을 확보하고 그 메모리에 새로운 값을 저장한다. 변수 값을 재할당하면 그전에 있던 값들은 변수를 가지고 있지 않다. 이것은 더이상 이전의 값이 필요없다는 것을 의미한다. 아무도 사용하고 있지 않는 불필요한 값들은 가비지 컬렉터(Garbage Collector)에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제될 지는 예측할 수 없다. ES6에서 도입된 const 키워드로 선언한 변수는 재할당이 금지된다. 따라서 const 키워드를 사용하면 상수를 표현할 수 있다. 3.5. 식별자 네이밍 규칙식별자(identifier)는 어떤 데이터를 식별해낼 수 있는 고유한 이름이다. 식별자는 아래와 같은 네이밍 규칙을 준수해야한다. 식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다. 단, 식별자는 숫자로 시작하는 것은 허용하지 않고, 특수문자를 제외한 문자, underscore( _ ), 달러 기호($)로 시작해야 한다. 변수명도 식별자이므로 위 네이밍 규칙을 따라야 한다. 변수는 쉼표( , )로 구분해 하나의 문에서 여러 개를 한번에 선언할 수 있다. 하지만 가독성이 나빠지므로 권장하지 않는다. 1var person, $elem, _name, first_name, val3; 자바스크립트는 대소문자를 구별하므로 아래의 변수는 각각 별개의 변수이다. 123var fistname;var firstName;var FIRSTNAME; 단어를 한눈에 구분하기 위해 자주 사용되는 네이밍 컨벤션은 아래와 같이 4가지가 있다. 123456789101112// 카멜 케이스 (camelCase)var firstName;// 스네이크 케이스 (snke_case)var first_name;// 파스칼 케이스 (PascalCase)var FirstName;// 헝가리언 케이스 (typehungarianCase)var strFirstName; // type + identifiervar $elem = $('.myClass') // jQuery 4. 데이터 타입이란 무엇인가? 왜 필요한가?컴퓨터는 한번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(byte 수)를 알아야한다. 숫자의 경우 8byte 단위로 읽어들이지 않으면 값이 훼손된다. 메모리 셀의 크기는 타입값이 할당되어 있어 자바스크립트 엔진이 타입을 인식하여 메모리 셀의 개수만큼 읽어 들인다. 데이터 타입이 필요한 이유 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 4.1. 값값(value)은 더 이상 평가할 수 없는 하나의 표현식이다. 12// 10 + 20은 표현식이다. 이 표현식은 평가되어 30이라는 값을 만든다.10 + 20 이 표현식은 자바스크립트 엔진에 의해 평가(evaluation)되어 30이라는 새로운 값을 생성한다. 새롭게 생성된 값 30은 더 이상 평가할 수 없다. 다시말해, 30을 평가하면 언제나 30이다. 값은 데이터 타입을 갖으며 메모리에 2진수, 즉 비트(bit)의 나열로 저장된다. 즉, 값에는 종류가 있다. 표현식 10 + 20 이 평가되어 생성한 값 30의 데이터 타입은 숫자 타입이다. 변수는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 12// 변수에는 표현식 10 + 20이 평가되어 생성한 값 30이 할당된다.var sum = 10 + 20; 변수 sum에 할당되는 것은 표현식이 아니라 표현식이 평가되어 생성한 값 30이다. 4.2. 값의 생성값은 다양한 방법(표현식)으로 생성할 수 있다. 가장 기본적인 방법은 리터럴 표기법을 사용하는 것이다. 5. 리터럴리터럴(literal)은 소스코드 안에서 직접 만들어 낸 고정된 값 자체를 말한다. 리터럴은 리터럴 표기법(literal notation)으로 생성한다. 5.1. 리터럴 표기법리터럴 표기법(literal notation)은 리터럴을 생성하는 방법이다. 리터럴 표기법은 값을 생성하는 가장 기본적인 방법이라고 할 수 있다. 자바스크립트 엔진은 리터럴 표기법으로 작성된 코드를 만나면, 코드가 실행되는 시점(런타임, runtime)에 리터럴을 해석하고 값을 생성한다. 123456789101112131415161718192021222324252627282930313233343536// 정수 리터럴1000// 부동 소숫점 리터럴10.5// 2진수 리터럴(0b로 시작)0b01000001// 8진수 리터럴(ES6에서 도입, 0o로 시작)0o101// 16진수 리터럴(ES6에서 도입, 0x로 시작)0x41// 문자열 리터럴'Hello'\"World\"// 불리언 리터럴truefalse//null 리터럴null// undefined 리터럴undefined// 객체 리터럴{name: 'Lee', gender: 'male'}// 배열 리터럴[1, 2, 3]// 함수 리터럴function(){}// 정규표현식 리터럴/ab+c 위 예제의 리터럴들은 표기법만 다를 뿐 메모리에는 동일한 2진수로 저장된다. 리터럴 표기법은 값을 생성하는 방법이다. 숫자 값을 생성하고 싶으면 개발자는 숫자 리터럴 표기법을 사용해 숫자 값의 생성을 자바 스크립트 엔진에게 요청한다. 자바스크립트 엔진은 숫자 리터럴을 해석하여 숫자 값을 생성하라는 개발자의 요청에 응답한다. 5.2. 값과 리터럴의 관계1var score = 100; 우변의 100은 리터럴인 동시에 값이다. 1var score = 50 + 50; 우변은 리터럴 표기법으로 두개의 리터럴 50을 만들고 + 연산자를 사용해 합산하고, 새로운 값을 생성한다. 이처럼 프로그램 내에서 값을 생성하는 문을 표현식(expression)이라 한다. 이처럼 기터럴 표기법은 값을 생성하는 가장 기본적인 방법이고, 이를 통해 생성된 리터럴은 값의 최소 단위이다. 리터럴은 그 자체로 값이 될 수 있지만 모든 값이 리터럴인 것은 아니다. 6. 표현식값은 다양한 표현식으로 생성할 수 있다. 표현식은 리터럴, 식별자(변수명, 함수명 등), 연산자, 함수 호출 등의 조합을 말한다. 표현식은 평가되어 하나의 값을 만든다. 즉, 표현식은 하나의 값으로 평가될 수 있는 문(statement)이다. 1234567891011121314151617// 리터럴 표현식10'hello'// 식별자 표현식sumperson.namearr[1]// 연산자 표현식10 + 20sum = 10sum !== 10// 함수/메소드 호출 표현식square()person.getName() 위 예제와 같이 가양한 표현식이 있지만 하나의 값으로 평가된다는 점에서 동일하다. 7. 데이터 타입의 분류자바스크립트의 모든 값은 원시타입(primitive type)과 객체 타입(object/reference type)으로 분류할 수 있다. 원시 타입(primitive type) 숫자(number) 타입 : 숫자(정수, 실수) 문자열(string) 타입 : 문자열 불리언(boolean) 타입 : 논리적 참과 거짓 undefined 타입 : 선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값 null 타입 : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 Symbol 타입 : ES6에서 새롭게 추가된 7번째 타입 객체 타입(object / reference type) : 객체, 함수, 배열 등 예를 들어 숫자 타입의 값 1과 문자열 타입의 값은 '1'은 비슷하게 보이지만 전혀 다른 값이다. 확보해야 할 메모리 공간의 크기도 다르고 메모리에 저장되는 2진수도 다르며 읽어 들여 해석하는 방식도 다르다. 개발자는 명확한 의도를 가지고 타입을 구별하여 값을 만들 것이고 자바스크립트 엔진은 타입을 구별하여 값을 취급할 것이다. 7.1. 숫자 타입c나 java의 경우, 정수와 실수를 구분하여 다양한 숫자 타입으로 구분하지만, 자바스크립트는 독특하게 모든 수를 실수로 처리하며 정수만을 표현하기 위한 데이터 타입이 없다. 7.2. 문자열 타입문자열은 작은 따옴표'', 큰 따옴표&quot;&quot;, 백틱 ``` ` 안에 텍스트를 넣어 생성한다.","link":"/2019/04/30/til-20190430/"},{"title":"웹 브라우저, 변수","text":"1. 웹 브라우저 1. 1. 웹 브라우저는 어떻게 동작하는가? 웹 페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시한다. 브라우저는 서버로부터 HTML, CSS, 자바스크립트, 이미지 파일 등을 응답 받는다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다. 1.1. HTTP서버와 브라우저간의 통신규약을 말한다. 1.1.1. HTTP 1.x version 통신과정 Initial Request(https://www.naver.com)와 Response(index.html) Request(Get/CSS)와 Response(CSS) Request(Get/JavaScript)와 Response(JavaScript) 1.1.2. HTTP 2.x version 통신과정 한번의 Request로 필요한 Response를 다 받는다. 1.2. Request 와 Response브라우저가 서버에 Initial Request(https://www.naver.com) 를 보내면 서버는 브라우저에 Response(index.html, 다운로드)를 보내준다. 다운로드패킷단위로 쪼개진 2진수를 케이블을 통해 보낸다. PasingResponse받은 파일(텍스트로 되어있는 소스코드(html))을 브라우저가 이해하기 위해 해석한다. DOM(DOM Tree)HTML 파일을 읽어 pasing 한 결과. CSSOM(씨쏨트리)CSS를 읽어 pasing 한 결과. Render TreeDOM과 CSSOM을 합친(merge) 결과. Sysntax TreeJavaScript 가 pasing 된 결과로, DOM tree와 CSSOM tree 가 완성되어있어야 적용이 가능하다. Rendering Engine(브라우저)HTML과 CSS의 처리를 담당한다. JavaScript Engine(브라우저)JavaScript의 처리를 담당한다. 1.3. AST(Abstract Syntax Tree)문자열로 이루어진 자바스크립트 코드를 해석하기 위한 일련의 과정. 토크나이징(Tokenizing) 문자열로 이루어진 소스 코드를 토큰(코드의 최소 단위)들로 분리한다. 파싱(Pasing) 토큰들의 집합을 구문 분석하여 AST를 생성한다. 코드 실행 생성된 AST는 복잡한 과정을 통해 바이트 코드 또는 머신 코드로 변환되어 인터프리터에 의해 실행된다. 일단은 알아두자 식별자들의 모임이 실행컨텍스트에 렉시컬 환경에 들어있다. 자바스크립트엔진은 텍스트가 들어오면 토큰으로 나눠 문법에 맞으면 실행시킨다. version 표시ver 10.1.2 마지막 자리(2) 버그 fix를 수정한다. 두번째 자리(1) 기능향상을 한다. (minor버전) 첫번째 자리(10) 버젼업을 한다. (major버전, Break Change가 있는지 확인해야한다.) Break Change : 전버젼과 호환이 안된다. ver 10.0.2와 ver 10.100.32 는 호환이 가능하다. 2. 변수 2.1. 변수는 무엇인가, 왜 필요한가?변수(variable)는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 간단히 말하자면 변수는 값을 저장하고 참조하는 메커니즘으로 값에 이름을 붙인 것이다. 만약 변수가 없다고 가정해보자. 숫자값 10과 20의 연산 결과 값 30은 임의의 메모리 주소에 할당된다. 이 결과 값을 한 번만 사용한다면 상관없다. 하지만 재사용하기 위해선 주소값을 알아야 참조를 하는데 주소값에 직접적인 접근이 불가해 메모리 공간에 변수라는 이름을 선언해주는 것이다. 2.2. 변수 선언변수 선언(variable declaration)이란 변수명(식별자)을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다. 변수를 선언할 때는 var, let, const 키워드를 사용한다. 자바스크립트 엔진은 변수 선언 후 변수 값을 할당하지 않으면 undefined라는 값을 암묵적으로 할당해 초기화 한다. 선언 단계(Declaration phase)변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계(Initialization)값을 저장하기 위해 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. 할당변수에 값을 저장하는 것. 참조변수에 저장된 값을 읽어 들이는 것. 선언변수명(식별자)을 등록하여 자바스크립트 엔진에 존재를 알리는 것. 정의식별자의 정체를 알리는 것 평가값과 값을 연산하는 행위. 실행값과 값을 비교하는 행위. cell(셀)메모리의 1byte를 1개의 셀이라한다. 한개의 셀에는 한개의 아스키코드를 담을 수 있다. ReferenceError식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 참조 에러다.(변수를 사용하려면 반드시 선언이 필요하다.) 중간 중간 용어 알기 네스팅(중첩) 태그의 부자관계는 네스팅으로 표현한다. 메타데이터 컴퓨터에게 주는 데이터로, HTML의 head 에 쓰는 화면에 안보이는 내용이 들어갈 수 있다. 룰셋 (CSS) 선택자와 속성의 뭉텅이","link":"/2019/05/01/til-20190501/"},{"title":"예습, 러버덕, 기초 알고리즘","text":"아침 러버덕 변수 하나의 값은 사용자가 재사용을 필요로 할 수도 있다. 이 때 값이 저장되어 있는 메모리 주소를 직접 연결하지 않고 메모리 주소를 식별하기 위해 붙인 이름이다. 변수 선언 변수의 존재를 자바스크립트 엔진에 알려 관리하도록 하는 것 할당 새로운 메모리에 값이 저장된 후 변수가 그것을 가리키는 행위 식별자 값을 구별할 수 있는 고유한 이름 정의 식별자의 정체를 알리는 것, 자바스크립트에서는 정의와 동시에 할당이 일어난다. 기초 알고리즘 문자열 s와 자연수 n을 입력받아, 만약 s의 길이가 n보다 작으면 s의 왼쪽에 공백으로 추가해서 길이가 n이 되게 만든 후 반환하고, 아니면 s를 그대로 반환하는 함수를 작성해보세요. 123456789101112function leftPad(str, num){ str_split = str.split(''); if(str.length &lt; num){ for(var i = 0; i &lt; num-str.length; i++){ str_split.unshift(' '); } return a = str_split.join(''); } else{ return str; }} 두 문자열을 입력받아, 대소문자를 구분하지 않고(case insensitive) 두 문자열이 동일한지를 반환하는 함수를 작성하세요. 1234567function insensitiveEqual(a, b){ if(a == b){ return true; } else{ return false; }} 문자열을 입력받아, 문자열 안에 들어있는 모든 모음(a, e, i, o, u)의 갯수를 반환하는 함수를 작성하세요. 1234567891011var j = 0;for(var i = 0; i &lt;= arry.length; i++){ if(arry[i]==='a'|| arry[i] === 'e' || arry[i] === 'i' || arry[i] === 'o' || arry[i] === 'u'){ j++ } return j;} 1. 동적 타이핑 1.1. 동적 타입 언어와 정적 타입 언어자바스크립트의 모든 값은 데이터 타입을 갖는다. 그렇다면 변수는 데이터 타입을 갖을까? C나 Java와 같은 정적 타입(Static / Strong type) 언어는 변수를 선언할 때 변수의 데이터 타입을 사전에 선언해야 한다. 12345// 변수 c에는 1byte 정수 타입의 값(-128 ~ 127)만을 할당할 수 있다.char c;// 변수 num에는 4byte 정수 타입의 값(-2,124,483,647 ~ 2,124,483,647)만을 할당할 수 있다.int num; 정적 타입 언어는 변수의 타입을 변경할 수 없으며 변수에 선언한 타입에 맞는 값만을 할당할 수 있다. 이를 통해 타입의 일관성을 강제하여 보다 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다. 자바스크립트는 정적 타입 언어와는 다르게 변수를 선언할 때 타입을 선언하지 않는다. 다만 var,let, const 키워드를 사용해 변수를 선언할 뿐이고, 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 1234567891011121314151617181920212223242526var foo;console.log(typeof foo); // undefinedfoo = 3;console.log(typeof foo); // numberfoo = 'Hello';console.log(typeof foo); // stringfoo = true;console.log(typeof foo); // booleanfoo = null;console.log(typeof foo); // objectfoo = Symbol(); // 심볼console.log(typeof foo); // symbolfoo = {}; // 객체console.log(typeof foo); // objectfoo = []; // 배열console.log(typeof foo); // objectfoo = function () {}; // 함수console.log(typeof foo); // function 자바스크립트의 변수는 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있으므로 정적 타입 언어에서 말하는 데이터 타입과 개념이 다르다. 정적 타입언어와 동적타입언어의 차이는 변수의 타입이 결정되고 변수의 타입을 변경할 수 있냐 없냐에 있다. 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다.","link":"/2019/05/02/til-20190502/"},{"title":"변수, 데이터 타입, 값, 리터럴","text":"1. 변수변수(Variable)는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 1.1. 변수 선언의 차이12// 할당할 때 변수의 데이터 타입을 알 수 있다.var a; 12// 변수선언을 할 때 데이터 타입을 명시한다.int a; TypeScriptJavaScript에 정적타입언어를 사용한다. 1234567// 변수 선언과 undefined 초기화를 해준다.var x;// 변수 할당문, 우변의 값을 좌변에 할당한다.x = 100;console.log(x); 원시타입 : 변경이 불가능하다. 객체타입 : 변경이 가능하다. 1.2. 변수 선언의 실행 시점과 변수 호이스팅변순 선언은 런타임 이전에 실행된다. 이것을 변수 호이스팅이라 말한다. 2. 데이터 타입통상적인 자바스크립트 엔진은 숫자를 8byte 로 처리한다. 2.1. 왜 데이터 타입이 필요한가?값을 참조할 때 가장 선두 주소를 찾아 가는데 선두 주소로 부터 몇 바이트 단위로 가져오는지 알아야 하기 때문이다. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 3. 값값은 더이상 평가할 수 없는 하나의 표현식이다.표현식은 값을 생성하는 문이다. 123// 10 + 20 은 표현식이다. 이 표현식은 평가되어 30이라는 값을 만든다.// 10은 평가해도 10이고, 20을 평가해도 20이다.10 + 20 우변은 하나의 값이 올자린데 표현식으로 되어 있어서 표현식을 평가해 값으로 할당한다. 4. 값의 생성값은 다양한 방법(표현식)으로 생성할 수 있다. 가장 기본적인 방법은 리터럴 표기법을 사용하는 것이다. 4.1. 리터럴리터럴은 소스 코드 안에서 직접 만들어 낸 고정된 값 자체를 말한다. 좀 더 명확히 말하면 리터럴은 자바스크립트 엔진에 의해 값으로 평가된다. 리터럴은 리터럴 표기법으로 생성한다. 값을 만드는 방법은 리터럴 표기법(리터럴 표현식)을 사용한다. 12// 10과 20은 리터럴 표현식이다. 30은 리터럴 표현식으로 평가된 값이다.10 + 20 = 30 리터럴은 값이고, 값은 리터럴이 아니다. 평가되기 이전의 값을 리터럴이라고 한다. 4.2. 표현식값은 다양한 방법으로 생성할 수 있다. 표현식(expression)은 리터럴, 식별자, 연산자, 함수 호출 등의 조합을 말한다. 표현식은 평가(evaluation, 표현식을 해석하여 하나의 값을 만드는 과정)되어 하나의 값을 만든다. 즉, 표현식은 하나의 값으로 평가될 수 있는 문(statement)이다. 5. 숫자 타입1234// 숫자 타입의 3가지 특별한 값console.log(10 / 0); // Infinityconsole.log(10 / -0); // -Infinityconsole.log(1 * 'String'); // NaN(숫자가 아니다) 6. 문자열 타입문자열은 0개 이상의 유니코드들의 집합으로 전세계 대부분의 문자를 표현할 수 있다. 문자열은 작은 따옴표(‘’), 큰 따옴표(“”) 또는 백틱(``) 안에 텍스트를 넣어 생성할 수 있다. 7. 동적 타입 언어와 변수 7.1. 변수 사용시 주의해야 할 사항 변수의 사용을 적극적으로 줄인다. 변수의 개수가 많으면 많을수록 오류가 발생할 확률은 높아진다. 전역 변수는 사용하지 않는다. 변수의 생명주기를 최대한 짧게 만든다. 변수보다는 상수를 사용해 값의 변경을 억제한다. 변수명은 변수의 존재 이유를 파악할 수 있도록 명명한다. 8. 연산자 8.1. 표현식과 연산자표현식은 하나의 값으로 평가될 수 있는 문(표현식 문, expression statement)이다. 값을 만드는 방법은 리터럴과 표현식이 있다. 8.2. 문과 표현식문(statement)은 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령이다. 표현식인 문 : 값으로 평가된다. 변수에 할당할 수 있다. 표현식이 아닌문 : 값으로 평가되지 않는다. 변수에 할당할 수 없다.(변수선언, 함수정의, if문(제어문)) 8.3. 비교 연산자 삼항연산자 삼항연산자는 표현식이고 if문은 표현식이 아닌문이다.","link":"/2019/05/03/til-20190503/"},{"title":"러버덕, 복습, 예습","text":"아침 러버덕 값 더 이상 평가될 수 없는 표현식 문과 표현식 문은 표현식으로 이루어져 있다. 표현식인 문 변수에 할당할 수 있다. ex. 변수 선언문 표현식이 아닌 문 변수에 할당할 수 없다. ex. 할당문 리터럴 값을 만드는 방법 선언과 정의 선언 : 자바스크립트 엔진에 식별자를 알려 관리하도록 하는 것 정의 : 식별자의 정체를 알리는 것 호이스팅(변수, 함수) 변수의 선언이 자바스크립트의 런타임 이전에 실행되는 것 1. 웹브라우저HTTP 프로토콜을 이용해 서버와 브라우저가 Request(요청)와 Response(응답)을 주고 받는다. 서버가 Response를 주면 렌더링 엔진(HTML, CSS)과, 자바스크립트 엔진(JavaScript)에 의해 Parsing(텍스트로 된 파일을 컴퓨터가 알수있게 해석하는 것)된다. Parsing된 결과는 DOM(HTML이 해석된 결과), CSSOM(CSS가 해석된 결과), Sysntax Tree(JavaScript가 해석된 결과)트리로 변환 되고 DOM과 CSSOM 트리가 완성되면 Sysntax Tree가 앞에 두개에 영향을 끼쳐 Render Tree(다 합쳐진결과)로 결합된다. 2. 변수 2.1. 할당과 참조예제) 숫자 값 10과 20을 + 연산자로 합산하고 있다. 110 + 20 숫자 값 10과 20은 메모리 상의 임의의 위치(주소, address)에 저장되고, 연산 결과로 생성된 숫자 값 30도 메모리 상의 임의의 위치에 저장되지만 숫자 값 30은 재사용할 수 없다. 값의 재사용을 위해 변수(하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다)를 사용한다. 예제) 숫자 값 10과 20을 + 연산자로 합산하고, 변수 result 에 저장한다. 1var result = 10 + 20; 숫자 값 10과 20을 합산한 결과를 변수 result에 저장하는 것을 할당이라 하고, 변수에 저장 된 값을 읽어 들이는 것을 참조라고 한다. 변수명은 식별자로도 부른다. 식별자가 상위의 개념이고 변수, 함수, 클래스 등의 이름과 같은 식별자는 모두 선언에 의해 자바 스크립트 엔진에 식별자의 존재를 알린다. 2.2. 변수 선언변수 선언이란 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다. 변수를 사용하려면 반드시 선언이 필요하다. 선언시 var, let, const 키워드를 사용한다. 1var score; // 변수의 선언(변수 선언문) 키워드 var를 이용해 score라는 변수를 선언했다. 아직 값을 할당하지 않았지만 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 있다. 2.3. 변수 선언의 실행 시점과 변수 호이스팅12console.log(score); // undefinedvar score; 자바스크립트는 한줄씩 순차적으로 실행되므로 변수의 선언보다 참조가 앞에 있으면 에러를 발생할 것처럼 보인다. 하지만 에러는 발생하지 않는다. 위에 출력은 undefined로 나타난다. 자바스크립트는 변수 선언을 우선적으로 처리하기 때문이다. 런타임(소스코드가 순차적으로 실행되는 시점)이 아닌 이전의 파싱타임에 먼저 시행시켜 호이스팅이라는 작업을 하기 때문이다. 모든 선언문은 런타임이 아닌 파싱 타임에 먼저 실행된다. 2.4. 값의 할당1234var score; // 변수 선언score = 30; // 값의 할당var score = 30; // 변수 선언과 값의 할당 변수에 값을 할당할 때는 할당 연산자(=)를 기준으로 우변의 값을 좌변에 할당한다. 변수 score를 선언한 시점에는 undefined로 초기화되어 있다. score=30으로 값을 할당하는 행위는 엄밀히 따지면 30으로 값을 재할당했다고 한다. const 키워드 const는 상수를 표현하는 키워드로 값의 재할당이 금지된다. 2.5. 식별자 네이밍 규칙1234567891011// 카멜 케이스var firstName;// 스네이크 케이스var first_name;// 파스칼 케이스var FirstName;// 헝가리언 케이스var strFirstName; // type + identifier 3. 데이터 타입모든 값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 할당하고 참조하기 위해서는 확보해야할 메모리 공간의 크기와 읽어와야할 메모리 공간의 크기를 알아야한다. 1var score = 100; // type Number = 8byte; 위 예제에서 자바스크립트 엔진은 값 100을 숫자 타입으로 인식하고 선두 메모리 셀을 기준으로 8byte의 메모리 공간을 확보한다. 1score 참조를 위해서는 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 필요가 있다. 이때 컴퓨터는 한번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(byte 수)를 알아야 한다. 변수 score에는 숫자 타입의 값이 할당되어 있으므로 선두 메모리 셀을 기준으로 셀 8개를 읽어온다. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 4. 연산자 4.1. 표현식과 연산자표현식은 하나의 값으로 평가될 수 있는 문이다. 표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식 등이 있지만 결국 평가되어 하나의 값이 된다. 4.2. 문과 표현식문은 하나 이상의 표현식과 키워드의 조합으로 구성되어 자바스크립트 엔진에게 내리는 명령이다. 자바스크립트의 모든 코드는 문 또는 표현식이다. 표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것이다. 4.3. 표현식인 문과 표현식이 아닌 문표현식인 문과 아닌 문을 구별하기 위한 가장 간단한 방법은 병수에 할당해 보는 것이다. 표현식인 문은 변수에 할당할 수 있고, 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당할 수 없어서 에러가 발생한다. 1234567// 변수 선언문은 표현식이 아닌 문이다.var x;// 따라서 변수 선언문은 표현식이 아닌 문이다.var x = var y; // SyntaxError// 할당문 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.x = 100; 4.4. 연산자란?하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산등을 수행해 하나의 값을 만든다. 연산의 대상을 피연산자라 부른다. 4.5. 산술 연산자산술연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다. 산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다. 4.5.1. 이항 산술 연산자이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 피연산자의 값이 바뀌지 않고 언제나 새로운 값을 만든다. + : 덧셈 - : 뺄셈 * : 곱셈 / : 나눗셈 % : 나머지 4.5.2. 단항 산술 연산자단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 증가/감소(++ / –) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. 다시 말해 증가/감소 연산을 하면 피연산자의 값이 바뀐다. ++ : 증가 -- : 감소 + : 어떠한 효과도 없다. - : 양수를 음수로 음수를 양수로 반전한 값을 반환한다. 4.5. 할당 연산자할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다. 12345678910111213// = += -= *= /= %=x = 10; // 10x += 5; // x = x + 5 15x -= 5; // x = x - 5 10x *= 5; // x = x * 5 50x /= 5; // x = x / 5 10x %= 5; // x = x % 5 0 4.6. 비교 연산자비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다. == : 동등 비교 ( x == y, x와 y의 값이 같음) === : 일치 비교 (x === y, x와 y의 값과 타입이 같음) != : 부동등 비교 (x != y, x와 y의 값이 다름) !== : 불일치 비교 (x !== y, x와 y의 값과 타입이 다름) 123456789101112// 동등 비교5 == 5 // true// 타입은 다르지만 암묵적 타입 변환을 한다.5 == '5' // ture// 일치 비교5 === 5 // true// 암묵적 타입 변환을 하지 않고 값을 비교한다.// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.5 === '5' // false 4. 7. 대소 관계 비교 연산자대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다. &gt; : x &gt; y, x가 y보다 크다. &lt; : x &lt; y, x가 y보다 작다. &gt;= : x &gt;= y, x가 y보다 크거다 같다. &lt;= : x &lt;= y, x가 y보다 크거다 작다. 12345 &gt; 0 // true5 &gt; 5 // false5 &gt;= 5 // true5 &lt;= 5 // true 4.8. 삼항 조건 연산자삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 1조건식 ? 조건식이 true 일 때 반환할 값 : 조건식이 false일 때 반환할 값 12345678910111213141516171819var x = 2;// 2 % 2 는 0이고 0은 false로 암묵적 타입 변환이 된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수// if...else문으로 동일한 처리var x = 2;var result;if(x % 2){ result = '홀수';} else{ result = '짝수';}console.log(result); // 짝수 삼항 조건 연산자와 if…else문은 동일하게 사용할수 있지만 if…else문은 표현식이 아닌문이다. 따라서 if…else 문은 값처럼 사용할 수 없다. 4.9. 논리 연산자논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다. || : 논리합(OR) &amp;&amp; : 논리곱(AND) ! : 부정(NOT) 123456789101112131415// 논리합(||) 연산자console.log(true || true); // trueconsole.log(true || false); // trueconsole.log(false || true); // trueconsole.log(false || false); // false// 논리곱(&amp;&amp;) 연산자console.log(true &amp;&amp; true); // trueconsole.log(true &amp;&amp; false); // falseconsole.log(false &amp;&amp; true); // falseconsole.log(false &amp;&amp; false); // false// 논리 부정(!) 연산자console.log(!true); // falseconsole.log(!false); // true","link":"/2019/05/06/til-20190506/"},{"title":"제어문, 반복문, 조건문, 타입변환, 단축평가, 객체 리터럴","text":"1. 제어문제어문은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 가급적 if문과 for문의 사용을 지양해야한다. 실무에서는 for문을 대신해 함수를 사용하거나 for…in 등을 사용한다. 1.1. 블록문블록문은 중괄호로 묶은 것으로 블록 또는 코드블록이라고 부르기도 한다. 같이 실행되는 집합으로 본다. 블록문의 끝에는 세미콜론을 붙이지 않는다. 12345// 블록문{var x = 100;console.log(x);} 2. 조건문조건문은 주어진 조건식(블리언 값으로 평가될 수 있는 표현식)의 결과에 따라 코드 블럭의 실행을 결정한다. 2.1. if…else 문주어진 조건식의 평가 결과에 따라 실행할 코드 블록을 결정한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 강제로 변환되어 논리적 참, 거짓을 구별한다.(블리언 값) 1234567if(조건식1){ // 조건식1이 참이면 실행한다.} else if(조건식2){ // 조건식1이 거짓으로 판명나 건너 뛰고 조건식2가 참이면 실행한다.} else{ // 모든 조건식이 거짓이면 실행한다.} 2.2. switch 문주어진 표현식을 평가하여 그 값과 일치하는 case문으로 이동하여 코드 블럭을 실행한다. if…else문은 불리언 값으로 평가되지만 switch 문의 표현식은 문자열, 숫자 값인 경우가 많다. break가 없으면 실행된 후 탈출하지 않고 break를 만날 때까지 모두 실행한다. 이것을 폴스루(fall through)라 한다. 12345678910switch(표현식){ case 표현식1: // 표현식과 표현식1이 일치하면 실행한다. break; // 이 블록이 실행되고 문을 탈출한다. case 표현식2: // 표현식과 표현식2가 일치하면 실행한다. break; default: // 표현식과 일치하는 case가 없을 때 실행한다.} 3. 반복문반복문은 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 검사하여 여전히 참인 경우 코드 블록을 실행한다. 3.1. for 문for문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다. 123456789for (변수 선언문 또는 할당문; 조건식; 증감식) { 조건식이 참인 경우 반복 실행될 문;}for(var i = 0; i &lt; 2; i++){ console.log(i);}// 결과 : 0 1 3.2. while 문while 문은 주어진 조건식의 평가 결과 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 종료한다. 123456789var count = 0;// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.while (count &lt; 3) { console.log(count); count++;} // 결과 : 0 1 2 4. 타입 변환 4.1. 타입 변환이란?개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환이라 하고, 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 타입 변환이 되는 것을 암묵적 타입 변환이라 한다. 123456789101112131415161718192021222324// 문자열 타입 변환 var x = 10; // 명시적 타입 변환 var str1 = x.toString(); // '10' // 암묵적 타입 변환 var str2 = x + ''; // '10'// 숫자 타입 변환 var x = '10'; // 명시적 타입 변환 var num1 = Number(x); // 10 // 암묵적 타입 변환 var num2 = +x; // 10// 블리언 타입 변환 var num = 1; var str = '0'; // 명시적 타입 변환 var boo1 = Boolean(num); // true var boo1 = Boolean(str); // false // 암묵적 타입 변환 var boo2 = !!num; // true var boo2 = !!str; // false 5. 단축 평가논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자의 연산 결과는 불리언 값이 아닐 수도 있다. 이 두 연산자는 언제나 피연산자 중 어느 한쪽 값을 반환한다. 논리합 연산자는 두개의 피연산자가 모두 true로 평가될 때 true로 반환한다. 1234// 논리합 연산자'Cat' &amp;&amp; 'Dog' // 'Dog'false &amp;&amp; 'Dog' // false'Cat' &amp;&amp; false // false 논리곱 연산자는 두개의 피연산자 중 하나만 true로 평가되도 true를 반환한다. 1234// 논리합 연산자'Cat' || 'Dog' // 'Cat'false || 'Dog' // 'Dog''Cat' || false // 'Cat' 6. 객체 리터럴객체를 만드는 방법은 객체 리터럴이다. 원시 값은 변경 불가능한 값(immutable value)이지만 객체는 변경 가능한 값(mutable value)이다. 자바스크립트의 객체는 키(key)와 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 프로퍼티의 동작을 나타내는 것은 메소드(Method)라고 한다. 프로퍼티는 키와 값으로 구성되어 있다. 대상 객체에 관심있는 것만 나열하는 작업을 추상화라고 한다. 객체는 데이터를 의미하는 프로퍼티와 데이터를 참조하고 조작할 수 있는 동작을 의미하는 메소드로 구성된 집합이다. 6.1. 프로퍼티객체는 프로퍼티들의 집합이며 프로퍼티는 키와 값으로 구성된다. 그중에 프로퍼티 값이 함수인 경우를 메소드라 부른다. 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol값 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 프로퍼티 키 네이밍을 할 때 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다. 1234567var sungjin = { name: 'choisungjin', age: 25, // 규칙을 따름 'w-o-w': 'hoooo' // 규칙을 따르지 않음}console.log(sungjin); // {name: 'choisungjin, age: 25'} 6.2. 프로퍼티 접근12345678910var sungjin = { name: 'choisungjin'};// 마침표 표기법console.log(person.name); // choisungjin// 대괄호 표기법// 네이밍 규칙을 지키지 않은 경우 무조건 대괄호 표기법 사용console.log(person['name']); // choisungjin 6.3. 프로퍼티 값 갱신이미 있는 키에 값을 할당하면 갱신된다. 12345678var sungjin = { age: 20};// person객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신된다.sungjin.age = 24;console.log(sungjin); // {age: 24} 6.4. 프로퍼티 동적 생성존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다. 1234567var sungjin = { age: 24};sungjin.name = 'ChoiSungJin';console.log(sungjin); // {age: 24, name: 'ChoiSungJin'} 6.5. 프로퍼티 삭제delete 연산자를 사용해 객체의 프로퍼티를 삭제한다. 12345678var sungjin = { age: 24, name: 'ChoiSungJin'};delete sungjin.age;console.log(sungjin); // {name: 'ChoiSungJin'} 6.6. 프로퍼티 키 동적 생성프로퍼티의 키를 동적으로 생성할 수 있다. 123456789101112// ES6const prefix = 'prop';let i = 0;// 내부에서 프로퍼티 키 동적 생성var obj = { [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i};console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}","link":"/2019/05/07/til-20190507/"},{"title":"til_20190508","text":"","link":"/2019/06/07/til-20190508/"},{"title":"til_20190509","text":"","link":"/2019/06/07/til-20190509/"},{"title":"til_20190510","text":"","link":"/2019/06/07/til-20190510/"},{"title":"til_20190513","text":"","link":"/2019/06/07/til-20190513/"},{"title":"this","text":"아침 러버덕 일급객체의 조건은 무엇인가? 변수, 자료구조(객체, 배열 등) 할당할 수 있다. 매개변수에 전달할 수 있다. 함수의 반환값으로 사용할 수 있다. 무명의 리터럴로 생성할 수 있다. 프로토타입 기반 상속의 이점은 무엇인가?메소드의 중복을 제거하여 메모리 낭비를 막을 수 있다. ‘constructor’,‘prototype’, __proto__에 대해 설명해보세요 __proto__ : 인스턴스가 프로토타입에 접근하기 위한 접근자 프로퍼티이다. prototype : 생성자 함수에 접근하기 위한 프로퍼티이다. constructor : 컨스트럭터, 컨스트럭터는 생성자이다. 프로토타입 체인에 대해 설명해보세요 프로퍼티에 접근하기 위해서는 프로토타입 체인을 상위의 프로토타입을 따라 찾는다. 1. thisthis는 자신이 속한 객체를 가리키는 자기 참조 변수이다. this에 바인딩 되는 객체는 함수 호출 방식에 따라 변화하여 결정되고, 태초에 생겼을 때 전역(window)으로 초기화 돼있다. 1.1. 일반 함수 호출일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다. 12345678function foo() { this; // window function bar() { this; // window } bar();}foo(); 하지만 메소드 내에서 정의한 중첩함수, 콜백함수에 this가 전역 객체를 바인딩하는 것은 헬퍼함수로서의 문제가 있다. 때문에 this를 외부한수로 바인딩 해주어야 하는데 방법은 아래와 같다. 1234567891011121314151617181920212223var value = 1;const obj = { value: 100, foo() { // this 바인딩(obj)를 변수 that에 할당한다. const that = this; // 콜백 함수 내부에서 this 대신 that을 참조한다. setTimeout(function () { console.log(that.value); // 100 }, 100); // bind를 사용한 방법 // 인수는 함수 외부에서 넣어주는 것이다. setTimeout(function () { console.log(this.value); // 100 }.bind(this), 100); }};obj.foo(); 1.2. 메소드 호출메소드 내부의 this는 메소드를 호출한 객체에 바인딩된다. 12345678const person = { name: 'Choi', getName() { return this.name; // 아래에 메소드를 호출한 객체인 person이 바인딩된다. }};console.log(person.getName()); // Lee 1.3. 생성자 함수 호출생성자 함수 내부의 this는 생성자 함수가 미래에 생성할 인스턴스가 바인딩된다. 123456789101112function Person(name) { this.name = name; // 생성자 함수로 생설할 빈객체(인스턴스)를 가리킨다. this.sayHello = function () { return `안녕하십니까 ${this.name}입니다.`; };}const me = new Person('sungjin');const you = new Person('gyuha');console.log(me.sayHello()); // 안녕하십니까 sungjin입니다.console.log(you.sayHello()); // 안녕하십니까 gyuha입니다. 1.4. call / apply 정적 메소드는 this가 필요없다. 12345678// apply 사용법const arr = [1, 2, 3, 4, 5];// es5Math.max.apply(null, arr);// es6Math.max(...arr); 연습 문제1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/*1. 짝수와 홀수evenOrOdd 함수는 정수 num을 매개변수로 받는다. num은 1이상의 정수이며, num이 음수인 경우는 없다. num이 짝수일 경우 'Even'을 반환하고 홀수인 경우 'Odd'를 반환하도록 evenOrOdd 함수를 완성하라.단, if문을 사용한 답과 3항 연산자를 사용하는 답 두가지를 제시하여야 한다.*/// if문function evenOrOdd(num) { if (num % 2 === 0) return 'Even'; return 'Odd';}console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even// 3항 연산자function evenOrOddd(num) { return num % 2 === 0 ? 'Even' : 'Odd';}console.log(evenOrOddd(2)); // Evenconsole.log(evenOrOddd(3)); // Oddconsole.log(evenOrOddd(1000)); // Even/*#2. 1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라.단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다.(hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n]*/// 기존 방법// function getCount8() {// let count = 0;// for (let i = 1; i &lt;= 10000; i++) {// const num = i + '';// for (let j = 0; j &lt; num.length; j++) {// if (num[j] === '8') {// count += 1;// }// }// }// return count;// }console.log(getCount8()); // 4000// 강사님 제안function getCount8() { let count = 0; let str = ''; for (let i = 0; i &lt; 10000 + 1; i++) { str += i; } for (let j = 0; j &lt; str.length; j++) { if (str[j] === '8') count += 1; } return count;}console.log(getCount8()); // 4000/*3. 문자열 다루기alphaString46 함수는 문자열 s를 매개변수로 입력받는다. s의 길이가 4 ~ 6이고, 숫자로만 구성되어 있는지 확인하는 alphaString46 함수를 완성하라.예를 들어 s가 'a234'이면 false를 리턴하고 '1234'라면 true를 리턴한다.*/function alphaString46(s) { const result = isNaN(s) === false &amp;&amp; (s.length &gt; 3 &amp;&amp; s.length &lt; 7) ? true : false; return result;}console.log(alphaString46('1234')); // trueconsole.log(alphaString46('9014')); // trueconsole.log(alphaString46('723')); // falseconsole.log(alphaString46('a234')); // falseconsole.log(alphaString46('')); // falseconsole.log(alphaString46()); // false","link":"/2019/05/15/til-20190515/"},{"title":"API사용 연습문제","text":"1. Math.PI양수를 입력받아 이 수를 반지름으로 하는 원의 넓이를 반환하는 함수를 작성하세요. 12345function circleArea(n) { return (n ** 2) * Math.PI;}console.log(circleArea(10)); // 314.1592653589793 2. Math.random두 정수 min, max 를 입력받아, min 이상 max 미만인 임의의 정수를 반환하는 함수를 작성하세요. 1234567function minToMax(min, max) { const sub = max - min; return Math.floor((Math.random() * sub) + min);}console.log(minToMax(2, 8)); // 2 ~ 7 중 랜덤의 수 3. Math.ceil정수를 입력받아, 5 단위로 올림한 수를 반환하는 함수를 작성하세요. 1234567891011121314151617181920212223// 처음 생각한 방법function ceilBy5(n) { const i = 1; while ((n % 5) !== 0) { n += i; } return n;}console.log(ceilBy5(30)); // 30console.log(ceilBy5(32)); // 35console.log(ceilBy5(37)); // 40// 강사님의 의도function ceilby5(num) { return Math.ceil(num / 5) * 5;}console.log(ceilBy5(30)); // 30console.log(ceilBy5(32)); // 35console.log(ceilBy5(37)); // 40 4. toString임의의 HTML 색상 코드를 반환하는 함수를 작성하세요. 12345678910111213141516171819202122232425262728293031323334353637383940414243// 처음 생각한 방법function hexNumber() { return Math.floor(Math.random() * 10);}function hexString() { return String.fromCharCode(Math.floor((Math.random() * 5) + 65));}function random() { return Math.floor(Math.random() * 2);}function htmlHexCode() { let result = '#'; for (let i = 0; i &lt; 6; i++) { const reload = [hexNumber(), hexString()]; result += reload[random()]; } return result;}console.log(htmlHexCode()); // #92F01Aconsole.log(htmlHexCode()); // #00FF12// 강사님의 의도function htmlHexCode() { let result = '#'; for (let i = 0; i &lt; 6; i++) { result += Math.floor(Math.random() * 16).toString(16); } return result.toUpperCase();}console.log(htmlHexCode()); // #92F01Aconsole.log(htmlHexCode()); // #00FF12 5. Math.random() * numberrgb색상코드를 랜덤으로 반환하는 함수를 작성하세요. 1234567891011function randomRgbCode() { function randomNumber() { return Math.floor(Math.random() * 256); } return `rgb(${randomNumber()}, ${randomNumber()}, ${randomNumber()})`;}console.log(randomRgbCode()); // rgb(123, 44, 254);console.log(randomRgbCode()); // rgb(12, 3, 223); 6. String.substring, String.indexOf소수인 숫자와, 자릿수를 받아서 소수를 자리수만큼만 자른 뒤 반환하는 함수를 작성하세요. 123456789function fixFloat(num, a) { const str = num + ''; return str.substring(0, str.indexOf('.') + a + 1);}fixFloat(10.12345, 2); // 10.12fixFloat(15.5678, 1); // 15.5 7. String.replaceCamel case의 문자열을 입력받아, snake case로 바꾼 새 문자열을 반환하는 함수를 작성하세요. 1234567891011121314function camelToSnake(str) { let i = 0; while (str[i] !== str[i].toUpperCase()) { i += 1; } const newStr = str.replace(str[i], `_${str[i]}`); return newStr.toLowerCase();}console.log(camelToSnake('helloWorld')); // 'hello_world'","link":"/2019/05/16/til-20190516/"},{"title":"til_20190517","text":"","link":"/2019/06/07/til-20190517/"},{"title":"til_20190520","text":"","link":"/2019/06/07/til-20190520/"},{"title":"til_20190522","text":"","link":"/2019/06/07/til-20190522/"},{"title":"til_20190523","text":"","link":"/2019/06/07/til-20190523/"},{"title":"til_20190527","text":"","link":"/2019/06/07/til-20190527/"},{"title":"til_20190529","text":"","link":"/2019/06/07/til-20190529/"},{"title":"til_20190531","text":"","link":"/2019/06/07/til-20190531/"},{"title":"til_20190602","text":"","link":"/2019/06/07/til-20190602/"},{"title":"til_20190603","text":"","link":"/2019/06/07/til-20190603/"},{"title":"til_20190605","text":"TEST입니다.이거슨 코드의 테마를 보기위한 test.md입니다. 12345678let a = 1;const b = 2;function add(a, b) { return a + b;}add(a, b); 최성진나이 25살입니다.","link":"/2019/06/05/til-20190605/"}],"tags":[{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"웹 사이트","slug":"웹-사이트","link":"/tags/웹-사이트/"},{"name":"웹 표준","slug":"웹-표준","link":"/tags/웹-표준/"},{"name":"웹 접근성","slug":"웹-접근성","link":"/tags/웹-접근성/"},{"name":"linear-gradient","slug":"linear-gradient","link":"/tags/linear-gradient/"},{"name":"white-space","slug":"white-space","link":"/tags/white-space/"},{"name":"가상요소 선택자","slug":"가상요소-선택자","link":"/tags/가상요소-선택자/"},{"name":"애니메이션","slug":"애니메이션","link":"/tags/애니메이션/"},{"name":"시작","slug":"시작","link":"/tags/시작/"},{"name":"연습문제","slug":"연습문제","link":"/tags/연습문제/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"Math.PI","slug":"Math-PI","link":"/tags/Math-PI/"},{"name":"Math.random","slug":"Math-random","link":"/tags/Math-random/"},{"name":"Math.ceil","slug":"Math-ceil","link":"/tags/Math-ceil/"},{"name":"toString","slug":"toString","link":"/tags/toString/"},{"name":"String.substring","slug":"String-substring","link":"/tags/String-substring/"},{"name":"String.replace","slug":"String-replace","link":"/tags/String-replace/"},{"name":"String.indexOf","slug":"String-indexOf","link":"/tags/String-indexOf/"},{"name":"웹 브라우저","slug":"웹-브라우저","link":"/tags/웹-브라우저/"},{"name":"변수","slug":"변수","link":"/tags/변수/"},{"name":"예습","slug":"예습","link":"/tags/예습/"},{"name":"러버덕","slug":"러버덕","link":"/tags/러버덕/"},{"name":"기초 알고리즘","slug":"기초-알고리즘","link":"/tags/기초-알고리즘/"},{"name":"데이터 타입","slug":"데이터-타입","link":"/tags/데이터-타입/"},{"name":"제어문","slug":"제어문","link":"/tags/제어문/"},{"name":"반복문","slug":"반복문","link":"/tags/반복문/"},{"name":"조건문","slug":"조건문","link":"/tags/조건문/"},{"name":"객체 리터럴","slug":"객체-리터럴","link":"/tags/객체-리터럴/"},{"name":"복습","slug":"복습","link":"/tags/복습/"}],"categories":[{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"JavaScript","slug":"TIL/JavaScript","link":"/categories/TIL/JavaScript/"},{"name":"HTML & CSS","slug":"TIL/JavaScript/HTML-CSS","link":"/categories/TIL/JavaScript/HTML-CSS/"},{"name":"HTML & CSS","slug":"TIL/HTML-CSS","link":"/categories/TIL/HTML-CSS/"},{"name":"컴퓨터공학","slug":"TIL/컴퓨터공학","link":"/categories/TIL/컴퓨터공학/"},{"name":"컴퓨터공학","slug":"TIL/JavaScript/HTML-CSS/컴퓨터공학","link":"/categories/TIL/JavaScript/HTML-CSS/컴퓨터공학/"}]}